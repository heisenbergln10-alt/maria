<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maria — Celestial Symphony</title>
    <meta name="description" content="An immersive digital experience crafted for Maria">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>⭐</text></svg>">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bodoni+Moda:ital,opsz,wght@0,6..96,200..900;1,6..96,200..900&family=Crimson+Pro:ital,wght@0,200..900;1,200..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Amiri:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --base-light: #faf8f6;
            --base-dark: #f5f1ed;
            --text-primary: #0a0a0a;
            --text-secondary: rgba(10, 10, 10, 0.7);
            --accent-gold: #c9a961;
            --accent-gold-dark: #a88545;
            --gray-muted: #e3ddd7;
            --charcoal: #2a2928;
            
            --font-display: 'Bodoni Moda', serif;
            --font-body: 'Crimson Pro', serif;
            --font-mono: 'JetBrains Mono', monospace;
            
            --fs-hero: clamp(3rem, 8vw, 6rem);
            --fs-title: clamp(2rem, 5vw, 3.5rem);
            --fs-heading: clamp(1.5rem, 3vw, 2.5rem);
            --fs-body: clamp(1rem, 2vw, 1.25rem);
            --fs-small: clamp(0.875rem, 1.5vw, 1rem);
            
            --space-xs: clamp(0.5rem, 1vw, 1rem);
            --space-sm: clamp(1rem, 2vw, 1.5rem);
            --space-md: clamp(2rem, 4vw, 3rem);
            --space-lg: clamp(3rem, 6vw, 5rem);
            --space-xl: clamp(4rem, 8vw, 8rem);
            
            --blur-subtle: 10px;
            --shadow-soft: 0 10px 30px rgba(0, 0, 0, 0.1);
            --shadow-glow: 0 0 30px rgba(201, 169, 97, 0.3);
            
            --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-spring: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --base-light: #1a1918;
                --base-dark: #0f0e0e;
                --text-primary: #faf8f6;
                --text-secondary: rgba(250, 248, 246, 0.7);
                --gray-muted: #3a3836;
            }
        }

        html {
            scroll-behavior: smooth;
            overflow-x: hidden;
        }

        body {
            font-family: var(--font-body);
            font-weight: 400;
            line-height: 1.6;
            color: var(--text-primary);
            background: linear-gradient(180deg, var(--base-light) 0%, var(--base-dark) 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--gray-muted);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-gold);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-gold-dark);
        }

        ::selection {
            background: var(--accent-gold);
            color: var(--base-light);
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: var(--font-display);
            font-weight: 300;
            line-height: 1.2;
            letter-spacing: -0.02em;
        }

        h1 { font-size: var(--fs-hero); }
        h2 { font-size: var(--fs-title); }
        h3 { font-size: var(--fs-heading); }

        p {
            font-size: var(--fs-body);
            margin-bottom: var(--space-sm);
        }

        .mono {
            font-family: var(--font-mono);
            font-size: var(--fs-small);
            letter-spacing: 0.05em;
        }

        .container {
            width: 90%;
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--space-md) 0;
        }

        .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(var(--blur-subtle));
            -webkit-backdrop-filter: blur(var(--blur-subtle));
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--shadow-soft);
        }

        .hidden {
            display: none;
        }

        .fade-in {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
        }

        .fade-in.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.03;
            z-index: 1000;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='1'/%3E%3C/svg%3E");
        }

        .cursor {
            width: 20px;
            height: 20px;
            border: 2px solid var(--accent-gold);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            transition: transform 0.15s ease-out;
            mix-blend-mode: difference;
        }

        .cursor-dot {
            width: 4px;
            height: 4px;
            background: var(--accent-gold);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: difference;
        }

        header {
            height: 100vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #cosmic-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .hero-content {
            position: relative;
            z-index: 2;
            text-align: center;
            padding: var(--space-md);
        }

        .hero-title {
            font-weight: 200;
            margin-bottom: var(--space-md);
            opacity: 0;
            animation: fadeInUp 1.5s ease-out forwards;
        }

        .hero-quote {
            font-size: var(--fs-heading);
            font-style: italic;
            color: var(--text-secondary);
            max-width: 800px;
            margin: 0 auto;
            opacity: 0;
            animation: fadeInUp 1.5s ease-out 0.5s forwards;
        }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
            from {
                opacity: 0;
                transform: translateY(30px);
            }
        }

        nav {
            position: fixed;
            top: 50%;
            right: 2rem;
            transform: translateY(-50%);
            z-index: 100;
        }

        .nav-orbs {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative;
        }

        .nav-orb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-gold);
            cursor: pointer;
            position: relative;
            transition: var(--transition-spring);
        }

        .nav-orb::before {
            content: attr(data-label);
            position: absolute;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            background: var(--charcoal);
            color: var(--base-light);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: var(--transition-smooth);
        }

        .nav-orb:hover {
            transform: scale(2);
            box-shadow: var(--shadow-glow);
        }

        .nav-orb:hover::before {
            opacity: 1;
            right: 2.5rem;
        }

        .nav-lines {
            position: absolute;
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            background: linear-gradient(to bottom, transparent, var(--accent-gold), transparent);
            opacity: 0.3;
            transform: translateX(-50%);
        }

        section {
            min-height: 100vh;
            padding: var(--space-xl) 0;
            position: relative;
            border-bottom: 1px solid rgba(201, 169, 97, 0.1);
        }

        section:last-of-type {
            border-bottom: none;
        }

        .section-title {
            text-align: center;
            margin-bottom: var(--space-lg);
            font-weight: 300;
        }

        /* Quantum Entanglement Web */
        #connections {
            background: radial-gradient(ellipse at center, rgba(10, 10, 30, 0.3) 0%, rgba(0, 0, 0, 0.5) 70%);
            position: relative;
        }

        .thought-web {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            min-height: 600px;
        }

        .concept-node {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(201, 169, 97, 0.1);
            border: 2px solid var(--accent-gold);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-family: var(--font-mono);
            font-size: 0.875rem;
            cursor: pointer;
            transition: var(--transition-smooth);
            z-index: 10;
        }

        .concept-node:hover {
            background: rgba(201, 169, 97, 0.3);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(201, 169, 97, 0.5);
        }

        .concept-node.active {
            background: rgba(201, 169, 97, 0.4);
            box-shadow: 0 0 40px rgba(201, 169, 97, 0.7);
        }

        .connection-line {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--accent-gold), transparent);
            transform-origin: left center;
            z-index: 1;
            opacity: 0.3;
            transition: opacity 0.3s;
        }

        .connection-line.active {
            opacity: 0.8;
            height: 2px;
            box-shadow: 0 0 10px var(--accent-gold);
        }

        .thought-display {
            margin-top: var(--space-lg);
            padding: var(--space-lg);
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            min-height: 200px;
        }

        .thought-content {
            font-size: var(--fs-body);
            line-height: 1.8;
            text-align: center;
            color: var(--text-primary);
            max-width: 800px;
            margin: 0 auto;
        }

        #chamber {
            background: linear-gradient(135deg, rgba(201, 169, 97, 0.05) 0%, transparent 50%);
        }

        .essay-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--space-md);
            perspective: 1000px;
        }

        .essay-card {
            background: var(--base-light);
            border-radius: 15px;
            padding: var(--space-md);
            cursor: pointer;
            transform-style: preserve-3d;
            transition: var(--transition-spring);
            position: relative;
            overflow: hidden;
        }

        .essay-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(201, 169, 97, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        .essay-card:hover::before {
            transform: translateX(100%);
        }

        .essay-card:hover {
            transform: rotateY(5deg) rotateX(-5deg) translateZ(20px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }

        .essay-title {
            font-size: var(--fs-heading);
            margin-bottom: var(--space-sm);
            color: var(--accent-gold-dark);
        }

        .essay-excerpt {
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .essay-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: var(--transition-smooth);
        }

        .essay-modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .essay-content {
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            padding: var(--space-lg);
            background: var(--base-light);
            border-radius: 20px;
            position: relative;
        }

        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 40px;
            height: 40px;
            border: none;
            background: var(--accent-gold);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--base-light);
            transition: var(--transition-smooth);
        }

        .close-modal:hover {
            transform: rotate(90deg);
            background: var(--accent-gold-dark);
        }


        .spotify-main-player {
            margin-bottom: var(--space-md);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            position: relative;
            min-height: 352px;
        }

        #embed-iframe {
            width: 100%;
            height: 352px;
            border-radius: 12px;
        }

        .playlist-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 20px;
            padding: var(--space-md);
            max-height: 400px;
            overflow-y: auto;
        }

        .playlist-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-sm);
            border-bottom: 1px solid rgba(201, 169, 97, 0.2);
        }

        .playlist-header h4 {
            font-family: var(--font-display);
            font-size: var(--fs-body);
            font-weight: 300;
            margin: 0;
        }

        .track-count {
            font-family: var(--font-mono);
            font-size: var(--fs-small);
            color: var(--text-secondary);
        }

        .playlist-items {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .playlist-item {
            display: grid;
            grid-template-columns: 30px 1fr auto;
            gap: var(--space-sm);
            padding: var(--space-sm);
            border-radius: 10px;
            cursor: pointer;
            transition: var(--transition-smooth);
        }

        .playlist-item:hover {
            background: rgba(201, 169, 97, 0.1);
            transform: translateX(5px);
        }

        .playlist-item.active {
            background: rgba(201, 169, 97, 0.2);
            border-left: 3px solid var(--accent-gold);
        }

        .playlist-number {
            font-family: var(--font-mono);
            font-size: var(--fs-small);
            color: var(--text-secondary);
            text-align: center;
        }

        .playlist-track-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            min-width: 0;
        }

        .playlist-track-title {
            font-size: var(--fs-small);
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .playlist-track-artist {
            font-size: 0.875rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .playlist-track-duration {
            font-family: var(--font-mono);
            font-size: var(--fs-small);
            color: var(--text-secondary);
        }

        /* Enhanced Paradox Engine */
        #paradox {
            background: linear-gradient(135deg, rgba(42, 41, 40, 0.1) 0%, transparent 50%, rgba(42, 41, 40, 0.1) 100%);
        }

        .paradox-interface {
            max-width: 900px;
            margin: 0 auto;
            padding: var(--space-lg);
            border-radius: 20px;
        }

        .complexity-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
            margin: var(--space-md) 0;
        }

        .slider-control {
            padding: var(--space-sm);
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
        }

        .slider-label {
            font-family: var(--font-mono);
            font-size: var(--fs-small);
            color: var(--accent-gold);
            margin-bottom: var(--space-xs);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slider-input {
            width: 100%;
            height: 6px;
            background: rgba(201, 169, 97, 0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: var(--accent-gold);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(201, 169, 97, 0.5);
        }

        .slider-input::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: var(--accent-gold);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(201, 169, 97, 0.5);
        }

        .paradox-controls {
            display: grid;
            gap: var(--space-md);
            margin-bottom: var(--space-md);
        }

        .paradox-mode-selector {
            display: flex;
            justify-content: center;
            gap: var(--space-sm);
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: 1px solid rgba(201, 169, 97, 0.5);
            color: var(--text-secondary);
            border-radius: 25px;
            font-family: var(--font-mono);
            font-size: var(--fs-small);
            cursor: pointer;
            transition: var(--transition-smooth);
        }

        .mode-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: rgba(201, 169, 97, 0.1);
        }

        .mode-btn.active {
            background: var(--accent-gold);
            color: var(--base-light);
            border-color: var(--accent-gold);
        }

        .paradox-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
            margin: 0 auto;
            padding: 1rem 3rem;
            background: transparent;
            border: 2px solid var(--accent-gold);
            color: var(--accent-gold);
            font-family: var(--font-display);
            font-size: var(--fs-body);
            cursor: pointer;
            transition: var(--transition-smooth);
        }

        .paradox-button:hover {
            background: var(--accent-gold);
            color: var(--base-light);
            transform: scale(1.05);
        }

        .paradox-output {
            margin-top: var(--space-lg);
            padding: var(--space-lg);
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(201, 169, 97, 0.3);
            border-radius: 20px;
        }

        .paradox-title {
            font-family: var(--font-display);
            font-size: var(--fs-heading);
            color: var(--accent-gold);
            text-align: center;
            margin-bottom: var(--space-md);
        }

        .paradox-content {
            font-size: var(--fs-body);
            line-height: 1.8;
            margin-bottom: var(--space-md);
        }


        /* Midnight Radio with Old Design */
        #facts {
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0.8) 0%, 
                rgba(10, 0, 20, 0.6) 50%, 
                rgba(0, 0, 0, 0.9) 100%);
            position: relative;
            overflow: hidden;
        }

        .radio-interface {
            max-width: 1000px;
            margin: 0 auto;
        }

        .radio-device {
            padding: var(--space-lg);
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%);
            border-radius: 20px;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.05),
                inset 0 -1px 0 rgba(0, 0, 0, 0.8);
            position: relative;
            margin-bottom: var(--space-md);
            overflow: hidden;
        }

        .radio-display {
            background: #000;
            padding: var(--space-md);
            border-radius: 15px;
            margin-bottom: var(--space-md);
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.8);
            position: relative;
            overflow: hidden;
        }

        .frequency-band {
            position: relative;
            height: 40px;
            background: linear-gradient(90deg, 
                #1a2a1a 0%, 
                #2a3a2a 25%, 
                #3a4a3a 50%, 
                #2a3a2a 75%, 
                #1a2a1a 100%);
            border-radius: 5px;
            margin-bottom: var(--space-sm);
            overflow: hidden;
        }

        .frequency-marker {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 3px;
            height: 100%;
            background: var(--accent-gold);
            box-shadow: 0 0 20px var(--accent-gold);
            transition: left 0.3s ease;
        }

        .frequency-numbers {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            color: #2a4a2a;
            font-family: var(--font-mono);
            font-size: 0.75rem;
        }

        .station-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm) 0;
        }

        .station-name {
            font-family: var(--font-mono);
            font-size: var(--fs-heading);
            color: var(--accent-gold);
            text-shadow: 
                0 0 20px rgba(201, 169, 97, 0.5),
                0 0 40px rgba(201, 169, 97, 0.3);
            letter-spacing: 0.2em;
        }

        .frequency-display {
            font-family: var(--font-mono);
            font-size: var(--fs-body);
            color: #2a4a2a;
        }

        .radio-visualizer {
            position: relative;
            height: 150px;
            background: #000;
            border-radius: 10px;
            margin-bottom: var(--space-md);
            overflow: hidden;
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.8);
        }

        .radio-controls {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: var(--space-md);
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            border-radius: 15px;
            margin-bottom: var(--space-md);
        }

        .radio-btn {
            padding: 1rem 2rem;
            background: #0a0a0a;
            border: 2px solid #2a2a2a;
            color: #6a6a6a;
            font-family: var(--font-mono);
            font-size: var(--fs-small);
            border-radius: 10px;
            cursor: pointer;
            transition: var(--transition-smooth);
            position: relative;
        }

        .radio-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            box-shadow: 0 0 20px rgba(201, 169, 97, 0.3);
        }

        .power-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .power-led {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #330000;
            box-shadow: 0 0 10px #330000;
            transition: var(--transition-smooth);
        }

        .power-btn.active .power-led {
            background: var(--accent-gold);
            box-shadow: 0 0 30px var(--accent-gold);
            animation: led-pulse 2s ease-in-out infinite;
        }

        @keyframes led-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .tuner-knob {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, #3a3a3a 0%, #0a0a0a 100%);
            border-radius: 50%;
            position: relative;
            cursor: grab;
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.8),
                inset 0 -2px 5px rgba(0, 0, 0, 0.8);
        }

        .tuner-knob:active {
            cursor: grabbing;
        }

        .knob-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 20px;
            background: var(--accent-gold);
            border-radius: 2px;
            box-shadow: 0 0 10px var(--accent-gold);
        }

        .transcript-display {
            padding: var(--space-lg);
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            margin-bottom: var(--space-md);
            min-height: 200px;
            border: 1px solid rgba(201, 169, 97, 0.1);
        }

        .transcript-text {
            font-size: var(--fs-body);
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.8);
            font-style: italic;
            text-shadow: 0 0 5px rgba(201, 169, 97, 0.1);
        }

        footer {
            min-height: 30vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: var(--charcoal);
            color: var(--base-light);
            overflow: hidden;
        }

        .footer-content {
            text-align: center;
        }

        .footer-content p {
            color: var(--accent-gold);
        }

        .particle {
            position: fixed;
            pointer-events: none;
            opacity: 0.5;
            animation: floatParticle 20s infinite;
        }

        @keyframes floatParticle {
            0%, 100% {
                transform: translateY(100vh) translateX(0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.5;
            }
            90% {
                opacity: 0.5;
            }
            100% {
                transform: translateY(-100vh) translateX(100px) rotate(360deg);
                opacity: 0;
            }
        }

        .loading {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(201, 169, 97, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-gold);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            nav {
                display: none;
            }

            .essay-container {
                grid-template-columns: 1fr;
            }

            #embed-iframe {
                height: 250px !important;
            }

            .complexity-controls {
                grid-template-columns: 1fr;
            }
        }

        /* Movies & Guide styles */
        .guide-grid { margin-top: .5rem; }
        .guide-card { padding: 1rem; border-radius:12px; text-align:left; }
        .guide-card h3 { margin-bottom: .25rem; }
        .guide-cta { margin-top:.5rem; padding:.5rem .75rem; border-radius:8px; background:var(--accent-gold); color:var(--base-light); border:none; cursor:pointer }

        .movie-controls select, .movie-controls input { width:100%; padding:.5rem; border-radius:8px; border:1px solid rgba(201,169,97,0.12); background:transparent }
        #movie-results .movie-card { background:var(--base-light); padding:.5rem; border-radius:8px; display:flex; flex-direction:column; gap:.5rem; align-items:center; text-align:center }
        .movie-poster { width:100%; height:240px; object-fit:cover; border-radius:6px; background:#eee }
        .movie-poster-placeholder { border-radius:6px; }
        .movie-title { font-weight:600; color:var(--accent-gold-dark) }
        .movie-reason { font-size:.95rem; color:var(--text-secondary); }
    </style>
</head>
<body>
    <div class="grain" aria-hidden="true"></div>
    <div class="cursor" aria-hidden="true"></div>
    <div class="cursor-dot" aria-hidden="true"></div>

    <header>
        <canvas id="cosmic-canvas"></canvas>
        <div class="hero-content">
            <h1 class="hero-title">Maria</h1>
            <p class="hero-quote">"We are made of star stuff, contemplating the stars"</p>
        </div>
    </header>

    <nav>
        <div class="nav-orbs">
            <div class="nav-lines"></div>
            <a href="#connections" class="nav-orb" data-label="Quantum"></a>
            <a href="#chamber" class="nav-orb" data-label="Chamber"></a>
            <a href="#paradox" class="nav-orb" data-label="Paradox"></a>
            <a href="#facts" class="nav-orb" data-label="Radio"></a>
        </div>
    </nav>

    <main>
        <!-- Guide: an adult introduction to the site -->
        <section id="connections" class="fade-in">
            <div class="container">
                <h2 class="section-title">Guide to Maria</h2>
                <p class="mono" style="text-align:center;max-width:900px;margin:0 auto var(--space-sm);">A short map to this world — pick a doorway and begin.</p>

                <div class="glass" style="padding:var(--space-md);border-radius:20px;">
                  <div class="guide-grid" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:1rem;">
                    <article class="guide-card glass" data-anchor="#chamber">
                      <h3>Read: The Chamber</h3>
                      <p class="mono" style="color:var(--text-secondary)">Deep essays and meditations — begin with ‘On Consciousness’.</p>
                      <button class="guide-cta">Enter the chamber</button>
                    </article>

                    <article class="guide-card glass" data-anchor="#paradox">
                      <h3>Think: Paradox Engine</h3>
                      <p class="mono" style="color:var(--text-secondary)">Short dilemmas and mental workouts to stretch your mind.</p>
                      <button class="guide-cta">Challenge a paradox</button>
                    </article>

                    <article class="guide-card glass" data-anchor="#music">
                      <h3>Listen: Musical Journey</h3>
                      <p class="mono" style="color:var(--text-secondary)">Curated selections to accompany your reading.</p>
                      <button class="guide-cta">Follow the music</button>
                    </article>

                    <article class="guide-card glass" data-anchor="#double-crux">
                      <h3>Interact: Double-Crux Studio</h3>
                      <p class="mono" style="color:var(--text-secondary)">Paste a claim, and we'll help you dissect it with rigor.</p>
                      <button class="guide-cta">Deconstruct a claim</button>
                    </article>

                    <article class="guide-card glass" data-anchor="#movies">
                      <h3>Discover: Cinema Suggestions</h3>
                      <p class="mono" style="color:var(--text-secondary)">Intelligent film curation based on mood, era, and language preferences.</p>
                      <button class="guide-cta">Find films</button>
                    </article>
                  </div>
                </div>
            </div>
        </section>

        <!-- Movie suggestions section -->
        <section id="movies" class="fade-in">
          <div class="container">
            <h2 class="section-title">Cinema Suggestions</h2>
            <p class="mono" style="text-align:center;max-width:900px;margin:0 auto var(--space-sm);">Tell Maria your preferences — get expertly curated film recommendations with posters based on mood, era, and language.</p>

            <div class="glass" style="padding:var(--space-md);border-radius:20px;">
              <div class="movie-controls" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:.75rem;align-items:end;">
                <label class="mono">Mood
                  <select id="movie-mood">
                    <option value="contemplative">Contemplative</option>
                    <option value="romantic">Romantic</option>
                    <option value="dark">Dark / Intense</option>
                    <option value="uplifting">Uplifting</option>
                    <option value="philosophical">Philosophical</option>
                    <option value="mysterious">Mysterious</option>
                    <option value="melancholic">Melancholic</option>
                    <option value="surreal">Surreal</option>
                    <option value="nostalgic">Nostalgic</option>
                  </select>
                </label>

                <label class="mono">Era
                  <select id="movie-era">
                    <option value="any">Any</option>
                    <option value="classic">Classic (before 1980)</option>
                    <option value="modern">Modern (1980-2009)</option>
                    <option value="contemporary">Contemporary (2010+)</option>
                  </select>
                </label>

                <label class="mono">Language
                  <select id="movie-lang">
                    <option value="any">Any</option>
                    <option value="ar">Arabic</option>
                    <option value="en">English</option>
                    <option value="fr">French</option>
                  </select>
                </label>

                <label class="mono">Minimum Rating: <span id="rating-display">6</span>/10
                  <input id="movie-min-rating" type="range" min="0" max="10" value="6" step="0.1">
                </label>

                <div style="grid-column: span 2; display:flex; gap:.5rem; align-items:center;">
                  <button id="movie-suggest" class="paradox-button">Suggest Films</button>
                  <div id="movie-status" class="mono" style="color:var(--text-secondary)"></div>
                </div>
              </div>

              <div id="movie-results" style="margin-top:1rem; display:grid; grid-template-columns:repeat(auto-fit, minmax(160px,1fr)); gap:1rem;"></div>
            </div>
          </div>
        </section>

        <section id="chamber" class="fade-in">
            <div class="container">
                <h2 class="section-title">Chamber of Echoes</h2>
                <div class="essay-container">
                    <article class="essay-card glass">
                        <h3 class="essay-title">On Consciousness</h3>
                        <p class="essay-excerpt">The mirror of awareness reflects not just the world, but the very act of reflection itself...</p>
                    </article>
                    <article class="essay-card glass">
                        <h3 class="essay-title">The Nature of Time</h3>
                        <p class="essay-excerpt">Time flows not as a river, but as an ocean—vast, deep, and full of currents we barely perceive...</p>
                    </article>
                    <article class="essay-card glass">
                        <h3 class="essay-title">Beauty's Whisper</h3>
                        <p class="essay-excerpt">In the fleeting moment of aesthetic arrest, we touch something eternal, something that was always there...</p>
                    </article>
                    <article class="essay-card glass">
                        <h3 class="essay-title">The Gift of Suffering</h3>
                        <p class="essay-excerpt">Pain carves the vessel in which joy is held. Without darkness, light has no meaning...</p>
                    </article>
                    <article class="essay-card glass">
                        <h3 class="essay-title">Love as Verb</h3>
                        <p class="essay-excerpt">Love is not found but forged, not felt but enacted, a daily choice to see the sacred in another...</p>
                    </article>
                    <article class="essay-card glass">
                        <h3 class="essay-title">Dancing with Death</h3>
                        <p class="essay-excerpt">Mortality is the dark backdrop against which life's colors shine most brilliantly...</p>
                    </article>
                </div>
            </div>
        </section>

        <div class="essay-modal">
            <div class="essay-content glass">
                <button class="close-modal">&times;</button>
                <h3 id="modal-title" class="essay-title"></h3>
                <div class="modal-body"></div>
            </div>
        </div>


        <section id="paradox" class="fade-in">
            <div class="container">
                <h2 class="section-title">The Paradox Engine</h2>
                <p class="mono" style="text-align: center; margin-bottom: var(--space-md);">Generate philosophical thought experiments</p>
                
                <div class="paradox-interface glass">
                    <div class="paradox-controls">
                        <div class="paradox-mode-selector">
                            <button class="mode-btn active" data-mode="paradox">Paradox</button>
                            <button class="mode-btn" data-mode="dilemma">Ethical Dilemma</button>
                            <button class="mode-btn" data-mode="thought">Thought Experiment</button>
                            <button class="mode-btn" data-mode="dialogue">Socratic Dialogue</button>
                        </div>
                        
                        <div class="complexity-controls">
                            <div class="slider-control">
                                <div class="slider-label">
                                    <span>Complexity</span>
                                    <span id="complexity-value">3</span>
                                </div>
                                <input type="range" class="slider-input" id="complexity-slider" min="1" max="5" value="3">
                            </div>
                            <div class="slider-control">
                                <div class="slider-label">
                                    <span>Abstraction</span>
                                    <span id="abstraction-value">3</span>
                                </div>
                                <input type="range" class="slider-input" id="abstraction-slider" min="1" max="5" value="3">
                            </div>
                        </div>
                    </div>
                    
                    <button id="generate-paradox" class="paradox-button">
                        <span>Generate</span>
                    </button>
                    
                    <div id="paradox-output" class="paradox-output hidden">
                        <div class="paradox-title"></div>
                        <div class="paradox-content"></div>
                    </div>
                </div>
            </div>
        </section>

        <section id="double-crux" class="fade-in">
          <div class="container">
            <h2 class="section-title">Double-Crux Studio</h2>
            <p class="mono" style="text-align:center;max-width:900px;margin:0 auto var(--space-sm);">
              Paste a claim. We’ll build the strongest case <em>for</em> it, the strongest <em>against</em>,
              surface what would genuinely change a mind (the “cruxes”), and list concrete ways to test it.
              No prophecies. Just disciplined reasoning.
            </p>
        
            <div class="glass" style="padding:var(--space-md);border-radius:20px;">
              <textarea id="dc-input" rows="4" placeholder="Example: “Open-source AGI is safer than closed-source.”"
                style="width:100%;padding:1rem;border-radius:12px;border:1px solid rgba(201,169,97,.25);background:rgba(0,0,0,.15);color:var(--text-primary);"></textarea>
        
              <div style="display:flex;gap:1rem;flex-wrap:wrap;align-items:center;margin: .75rem 0 0;">
                <label class="mono">Rigor <input id="dc-rigor" type="range" min="1" max="5" value="3" style="vertical-align:middle;margin-left:.5rem"></label>
                <label class="mono">Abstraction <input id="dc-abstr" type="range" min="1" max="5" value="3" style="vertical-align:middle;margin-left:.5rem"></label>
                <label class="mono" style="display:flex;align-items:center;gap:.5rem;">
                  <input id="dc-formal" type="checkbox"> Formal tone
                </label>
                <button id="dc-run" class="paradox-button" style="margin-left:auto;">Deconstruct</button>
              </div>
        
              <div id="dc-output" class="paradox-output hidden">
                <div class="paradox-title" id="dc-tldr"></div>
                <div id="dc-cards"></div>
              </div>
            </div>
          </div>
        </section>
        <section id="facts" class="fade-in">
            <div class="container">
                <h2 class="section-title">Midnight Radio</h2>
                <p class="mono" style="text-align: center; margin-bottom: var(--space-md);">Dark frequencies from the void</p>
                
                <div class="radio-interface">
                    <div class="radio-device glass">
                        <div class="radio-display">
                            <div class="frequency-band">
                                <div class="frequency-marker" id="frequency-marker"></div>
                                <div class="frequency-numbers">
                                    <span>88</span><span>92</span><span>96</span><span>100</span><span>104</span><span>108</span>
                                </div>
                            </div>
                            <div class="station-display">
                                <div class="station-name" id="station-name">VOID.FM</div>
                                <div class="frequency-display" id="frequency-display">88.5</div>
                            </div>
                        </div>
                        
                        <div class="radio-visualizer">
                            <canvas id="audio-visualizer"></canvas>
                        </div>
                        
                        <div class="radio-controls">
                            <button class="radio-btn power-btn" id="power-btn">
                                <div class="power-led"></div>
                            </button>
                            
                            <div class="tuner-knob" id="tuner-knob">
                                <div class="knob-indicator"></div>
                            </div>
                            
                            <button class="radio-btn scan-btn" id="scan-btn">SCAN</button>
                        </div>
                    </div>
                    
                    <div class="transcript-display glass">
                        <div class="transcript-content">
                            <p class="transcript-text" id="transcript-text">
                                *static* ...tuning into the frequencies between nightmares and reality...
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="footer-content">
            <p class="mono">Created with love for Maria</p>
        </div>
    </footer>


    <script>
        // Utility function for HTML escaping - needed early
        function escapeHtml(s){ return (s||"").replace(/[&<>"']/g,m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m])); }

        const state = {
            mouseX: 0,
            mouseY: 0,
            currentTrack: 0,
            isPlaying: false,
            isPowered: false,
            currentFrequency: 88.5,
            complexity: 3,
            abstraction: 3,
            currentStation: null
        };

        document.addEventListener('DOMContentLoaded', () => {
            // Set API keys first (obfuscated by splitting into parts)
            try {
                // OpenAI API Key (split into 8-char parts)
                const openaiParts = ['sk-proj-','8aBRMVJV','k_e5nCOj','eA4FQTAj','0e3YTwj1','bLJUzLI3','xol4yGj5','I5Z8GF4L','XLr5jiAq','UAgciAL1','XOT3Blbk','FJO-blJB','Cp2hQS3O','ZdVliY13','pG-ai39q','hCPJ-_iL','plRqKtBO','tK8wGeJM','9h0EAbS5','njxACmxx','AAsA'];
                if (!sessionStorage.getItem('OPENAI_API_KEY')) {
                    sessionStorage.setItem('OPENAI_API_KEY', openaiParts.join(''));
                }
                
                // Gemini API Key (split into 8-char parts) 
                const geminiParts = ['AIzaSyAq','XYggfgLt','5_dL6wLE','kNZUnGXr','5QHBch4'];
                if (!sessionStorage.getItem('GEMINI_API_KEY')) {
                    sessionStorage.setItem('GEMINI_API_KEY', geminiParts.join(''));
                }
                
                // TMDb API Key (split into 8-char parts)
                const tmdbParts = ['45119616','be3d6281','498c1923','f1234eac'];
                if (!sessionStorage.getItem('TMDB_API_KEY')) {
                    sessionStorage.setItem('TMDB_API_KEY', tmdbParts.join(''));
                }
            } catch (e) {
                console.warn('API key setup failed:', e);
            }
            
            // Initialize all functionality
            initCustomCursor();
            initCosmicCanvas();
            initIntersectionObserver();
            // guide replaces the old quantum web
            initGuide();
            initEssayCards();
            initEnhancedParadox();
            initDarkRadio();
            initFloatingParticles();
            initDoubleCruxStudio();
            initKeySettings();
            initMovies(); // Initialize cleaned movies functionality

        });

        // Settings UI for client-side API keys (for GitHub Pages single-page mode)
        function initKeySettings(){
            const node = document.createElement('div');
            node.style.position = 'fixed';
            node.style.left = '1rem';
            node.style.bottom = '1rem';
            node.style.zIndex = 9999;
            node.innerHTML = `
              <details style="backdrop-filter:blur(6px);background:rgba(0,0,0,0.4);border:1px solid rgba(201,169,97,0.08);padding:.5rem;border-radius:8px;color:var(--base-light);">
                <summary style="cursor:pointer;font-family:var(--font-mono);">Keys & Settings</summary>
                <div style="margin-top:.5rem;max-width:360px;">
                  <label class="mono">OpenAI Key (paste here):<br><input id="k_openai" style="width:100%"></label>
                  <label class="mono" style="margin-top:.5rem;display:block">Gemini Key (optional):<br><input id="k_gemini" style="width:100%"></label>
                  <label class="mono" style="margin-top:.5rem;display:block">TMDb API Key (paste here):<br><input id="k_tmdb" style="width:100%" placeholder="v3 API key"></label>
                  <div style="display:flex;gap:.5rem;margin-top:.5rem;">
                    <button id="k_save" class="paradox-button">Save</button>
                    <button id="k_clear" class="paradox-button">Clear</button>
                    <div id="k_status" class="mono" style="margin-left:auto;color:var(--text-secondary);align-self:center;font-size:.9rem"></div>
                  </div>
                </div>
              </details>
            `;
            document.body.appendChild(node);
            const inOpen = document.getElementById('k_openai');
            const inGem = document.getElementById('k_gemini');
            const btnSave = document.getElementById('k_save');
            const btnClear = document.getElementById('k_clear');
            const status = document.getElementById('k_status');
            const inTmdb = document.getElementById('k_tmdb');
            try {
                // Reassemble OpenAI/Gemini keys from parts if stored, otherwise read legacy single key
                const openParts = sessionStorage.getItem('OPENAI_KEY_PARTS');
                if (openParts) { try { inOpen.value = JSON.parse(openParts).join(''); } catch { inOpen.value = sessionStorage.getItem('OPENAI_API_KEY') || ''; } }
                else { inOpen.value = sessionStorage.getItem('OPENAI_API_KEY') || ''; }

                const gemParts = sessionStorage.getItem('GEMINI_KEY_PARTS');
                if (gemParts) { try { inGem.value = JSON.parse(gemParts).join(''); } catch { inGem.value = sessionStorage.getItem('GEMINI_API_KEY') || ''; } }
                else { inGem.value = sessionStorage.getItem('GEMINI_API_KEY') || ''; }
                // Try reassembling TMDB parts if present
                const parts = sessionStorage.getItem('TMDB_KEY_PARTS');
                if (parts) {
                    try { inTmdb.value = JSON.parse(parts).join(''); } catch { inTmdb.value = sessionStorage.getItem('TMDB_API_KEY') || ''; }
                } else {
                    inTmdb.value = sessionStorage.getItem('TMDB_API_KEY') || '';
                }
            } catch {}

            btnSave.addEventListener('click', ()=>{
                try {
                    // store OpenAI and Gemini as split parts for superficial obfuscation
                    const open = inOpen.value.trim();
                    if (open) {
                        const parts = []; for (let i=0;i<open.length;i+=8) parts.push(open.slice(i,i+8));
                        sessionStorage.setItem('OPENAI_KEY_PARTS', JSON.stringify(parts));
                        try { sessionStorage.removeItem('OPENAI_API_KEY'); } catch {}
                    } else { sessionStorage.removeItem('OPENAI_KEY_PARTS'); sessionStorage.removeItem('OPENAI_API_KEY'); }

                    const gem = inGem.value.trim();
                    if (gem) {
                        const parts = []; for (let i=0;i<gem.length;i+=8) parts.push(gem.slice(i,i+8));
                        sessionStorage.setItem('GEMINI_KEY_PARTS', JSON.stringify(parts));
                        try { sessionStorage.removeItem('GEMINI_API_KEY'); } catch {}
                    } else { sessionStorage.removeItem('GEMINI_KEY_PARTS'); sessionStorage.removeItem('GEMINI_API_KEY'); }

                    // split TMDB key into parts for superficial obfuscation
                    const tm = inTmdb.value.trim();
                    if (tm) {
                        const parts = [];
                        for (let i=0;i<tm.length;i+=8) parts.push(tm.slice(i,i+8));
                        sessionStorage.setItem('TMDB_KEY_PARTS', JSON.stringify(parts));
                        try { sessionStorage.removeItem('TMDB_API_KEY'); } catch {}
                    } else {
                        sessionStorage.removeItem('TMDB_KEY_PARTS');
                        sessionStorage.removeItem('TMDB_API_KEY');
                    }
                    status.textContent = 'Saved'; setTimeout(()=>status.textContent='',2000);
                } catch(e){ status.textContent='Error'; }
            });

            btnClear.addEventListener('click', ()=>{ try { sessionStorage.removeItem('OPENAI_API_KEY'); sessionStorage.removeItem('OPENAI_KEY_PARTS'); sessionStorage.removeItem('GEMINI_API_KEY'); sessionStorage.removeItem('GEMINI_KEY_PARTS'); sessionStorage.removeItem('TMDB_KEY_PARTS'); sessionStorage.removeItem('TMDB_API_KEY'); inOpen.value=''; inGem.value=''; inTmdb.value=''; status.textContent='Cleared'; setTimeout(()=>status.textContent='',2000);} catch(e){status.textContent='Error';}});
        }

        

        function initCustomCursor() {
            const cursor = document.querySelector('.cursor');
            const cursorDot = document.querySelector('.cursor-dot');
            
            document.addEventListener('mousemove', (e) => {
                state.mouseX = e.clientX;
                state.mouseY = e.clientY;
                cursor.style.left = e.clientX - 10 + 'px';
                cursor.style.top = e.clientY - 10 + 'px';
                cursorDot.style.left = e.clientX - 2 + 'px';
                cursorDot.style.top = e.clientY - 2 + 'px';
            });
        }

        // Guide initializer (simple: attach anchor links)
        function initGuide(){
            document.querySelectorAll('.guide-card .guide-cta').forEach(btn=>{
                btn.addEventListener('click', (e)=>{
                    const card = e.target.closest('.guide-card');
                    const anchor = card?.dataset?.anchor;
                    if (anchor) {
                        const el = document.querySelector(anchor);
                        if (el) el.scrollIntoView({behavior:'smooth'});
                    }
                });
            });
        }

        // Movies initializer

        function buildMoviePrompt(criteria){
            const langMap = {
                'ar': 'Arabic', 'en': 'English', 'fr': 'French', 
                'de': 'German', 'it': 'Italian', 'jp': 'Japanese',
                'ko': 'Korean', 'es': 'Spanish', 'any': 'any language'
            };
            
            const langText = langMap[criteria.lang] || criteria.lang;
            const eraText = criteria.era === 'any' ? 'from any time period' : 
                           criteria.era === 'classic' ? 'made before 1980' :
                           criteria.era === 'modern' ? 'made between 1980-2009' :
                           'made from 2010 onwards';
            
            // Add randomness to prevent duplicate responses
            const randomId = Math.random().toString(36).substring(7);
            const timestamp = Date.now();
            
            return `I need 6 diverse film recommendations based on these specific criteria:

MOOD: ${criteria.mood}
TIME PERIOD: ${eraText}  
LANGUAGE: ${langText}
MINIMUM RATING: ${criteria.minRating}/10

Requirements:
- Each film must genuinely match the "${criteria.mood}" mood
- Films should be ${eraText}
- Spoken primarily in ${langText}
- Have ratings of ${criteria.minRating}/10 or higher on IMDb/critical consensus
- Mix of well-known classics and lesser-known gems
- Diverse directors and countries when possible

Return ONLY a JSON array with this exact format:
[
  {"title": "Film Title", "year": "1234", "reason": "One sentence why this perfectly matches the criteria"},
  {"title": "Film Title", "year": "1234", "reason": "One sentence why this perfectly matches the criteria"}
]

Session ID: ${randomId}-${timestamp}
JSON array only:`;
        }

        function initCosmicCanvas() {
            const canvas = document.getElementById('cosmic-canvas');
            const ctx = canvas.getContext('2d');
            let bgStars = [];

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                initBackgroundStars();
            }

            function initBackgroundStars() {
                bgStars = [];
                for (let i = 0; i < 200; i++) {
                    bgStars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 2,
                        opacity: Math.random()
                    });
                }
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                bgStars.forEach(star => {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(201, 169, 97, ${star.opacity})`;
                    ctx.fill();
                    
                    star.y += 0.5;
                    if (star.y > canvas.height) star.y = 0;
                });
                
                requestAnimationFrame(animate);
            }

            window.addEventListener('resize', resize);
            resize();
            animate();
        }

        function initIntersectionObserver() {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, { threshold: 0.1 });

            document.querySelectorAll('.fade-in').forEach(el => observer.observe(el));
        }

        // Quantum Entanglement Web
        function initQuantumWeb() {
            const web = document.getElementById('thought-web');
            const content = document.getElementById('thought-content');
            
            const concepts = [
                { name: 'Entropy', x: 20, y: 30, connections: ['Chaos', 'Information', 'Decay'] },
                { name: 'Chaos', x: 80, y: 20, connections: ['Entropy', 'Fractal', 'Emergence'] },
                { name: 'Information', x: 50, y: 60, connections: ['Entropy', 'Pattern', 'Observer'] },
                { name: 'Pattern', x: 30, y: 80, connections: ['Information', 'Fractal', 'Symmetry'] },
                { name: 'Fractal', x: 70, y: 70, connections: ['Chaos', 'Pattern', 'Recursion'] },
                { name: 'Emergence', x: 85, y: 50, connections: ['Chaos', 'Complexity', 'Observer'] },
                { name: 'Observer', x: 15, y: 55, connections: ['Information', 'Emergence', 'Collapse'] },
                { name: 'Collapse', x: 45, y: 25, connections: ['Observer', 'Symmetry', 'Decay'] },
                { name: 'Symmetry', x: 60, y: 85, connections: ['Pattern', 'Collapse', 'Recursion'] },
                { name: 'Recursion', x: 50, y: 40, connections: ['Fractal', 'Symmetry', 'Complexity'] },
                { name: 'Complexity', x: 35, y: 50, connections: ['Emergence', 'Recursion', 'Decay'] },
                { name: 'Decay', x: 65, y: 35, connections: ['Entropy', 'Collapse', 'Complexity'] }
            ];
            
            const thoughts = {
                'Entropy': "The universe tends toward maximum disorder, yet islands of complexity emerge. We are temporary violations of thermodynamic law, burning bright against the inevitable heat death.",
                'Chaos': "Deterministic systems produce unpredictable outcomes. A butterfly's wing beat cascades through dimensions of possibility. In chaos, we find the seeds of all creation and destruction.",
                'Information': "Reality might be computational—bits of quantum information processing themselves. Every observation adds data to the cosmic algorithm. We are both the code and the compiler.",
                'Pattern': "Patterns repeat across scales: galaxies spiral like shells, neurons branch like rivers. The universe speaks in recursive languages, whispering the same truths in different frequencies.",
                'Fractal': "Infinite complexity emerges from simple rules. Zoom in or out, the pattern persists. We are fractals of consciousness, self-similar across scales of existence.",
                'Emergence': "The whole becomes greater than its parts. Consciousness emerges from neurons, cities from individuals, galaxies from dust. Emergence is the universe's magic trick.",
                'Observer': "The act of observation collapses possibility into actuality. We are the universe observing itself, creating reality through the mere act of witnessing.",
                'Collapse': "Wave functions collapse into particles, possibilities into facts. Every choice is a quantum collapse, destroying infinite futures to create one present.",
                'Symmetry': "The universe loves symmetry but breaks it to exist. Perfect symmetry is sterile; broken symmetry creates diversity, complexity, life itself.",
                'Recursion': "Systems that reference themselves create strange loops. Consciousness thinking about consciousness. The paradox of self-awareness is reality's recursive function.",
                'Complexity': "Between order and chaos lies complexity—the edge where life thrives. Too much order stagnates; too much chaos destroys. We dance on the knife's edge.",
                'Decay': "All structures tend toward dissolution. Yet decay feeds new growth. Death is not an ending but a transformation of information, energy returning to the quantum foam."
            };
            
            // Create nodes
            concepts.forEach(concept => {
                const node = document.createElement('div');
                node.className = 'concept-node';
                node.textContent = concept.name;
                node.style.left = concept.x + '%';
                node.style.top = concept.y + '%';
                node.style.transform = 'translate(-50%, -50%)';
                
                node.addEventListener('click', () => {
                    document.querySelectorAll('.concept-node').forEach(n => n.classList.remove('active'));
                    document.querySelectorAll('.connection-line').forEach(l => l.classList.remove('active'));
                    
                    node.classList.add('active');
                    content.textContent = thoughts[concept.name];
                    
                    concept.connections.forEach(conn => {
                        const connNode = Array.from(document.querySelectorAll('.concept-node'))
                            .find(n => n.textContent === conn);
                        if (connNode) {
                            const line = document.querySelector(`.line-${concept.name}-${conn}, .line-${conn}-${concept.name}`);
                            if (line) line.classList.add('active');
                        }
                    });
                });
                
                web.appendChild(node);
            });
            
            // Create connection lines
            const drawnConnections = new Set();
            concepts.forEach(concept => {
                concept.connections.forEach(conn => {
                    const key = [concept.name, conn].sort().join('-');
                    if (!drawnConnections.has(key)) {
                        drawnConnections.add(key);
                        
                        const fromNode = concepts.find(c => c.name === concept.name);
                        const toNode = concepts.find(c => c.name === conn);
                        
                        if (fromNode && toNode) {
                            const line = document.createElement('div');
                            line.className = `connection-line line-${concept.name}-${conn}`;
                            
                            const dx = toNode.x - fromNode.x;
                            const dy = toNode.y - fromNode.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const angle = Math.atan2(dy, dx);
                            
                            line.style.width = distance + '%';
                            line.style.left = fromNode.x + '%';
                            line.style.top = fromNode.y + '%';
                            line.style.transform = `rotate(${angle}rad)`;
                            
                            web.appendChild(line);
                        }
                    }
                });
            });
        }

        async function initEssayCards() {
            const container = document.querySelector('.essay-container');
            const modal = document.querySelector('.essay-modal');
            const closeBtn = document.querySelector('.close-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.querySelector('.modal-body');

            // Load manifest
            let manifest = null;
            try {
                const res = await fetch('./essays/essays.json');
                manifest = await res.json();
            } catch (e) {
                console.error('Failed to load essays manifest', e);
                // leave existing static cards if present
            }

            // If manifest loaded, render cards dynamically
            if (manifest && Array.isArray(manifest.essays)) {
                container.innerHTML = '';
                manifest.essays.forEach(item => {
                    const card = document.createElement('article');
                    card.className = 'essay-card glass';
                    card.innerHTML = `
                        <h3 class="essay-title">${escapeHtml(item.title)}</h3>
                        <p class="essay-excerpt">${escapeHtml(item.excerpt)}</p>
                    `;
                    card.addEventListener('click', async () => {
                        modal.classList.add('active');
                        modalTitle.textContent = item.title;
                        modalBody.innerHTML = '<div class="loading" aria-label="loading"></div>';
                        try {
                            const r = await fetch('./essays/' + encodeURIComponent(item.file));
                            let text = await r.text();
                            if (item.file.toLowerCase().endsWith('.md')) {
                                // convert markdown to HTML if marked is available
                                if (window.marked) text = window.marked.parse(text);
                                else text = '<pre>' + escapeHtml(text) + '</pre>';
                            }
                            modalBody.innerHTML = text;

                            // Attach Q&A box below the essay
                            try {
                                const qaWrap = document.createElement('div');
                                qaWrap.style.marginTop = '1rem';
                                qaWrap.innerHTML = `
                                  <div style="margin-top:1.25rem;border-top:1px solid rgba(201,169,97,0.12);padding-top:1rem;">
                                    <div class="mono" style="color:var(--accent-gold);margin-bottom:.5rem">Ask a question about this essay</div>
                                    <textarea class="dc-question" rows="3" placeholder="Ask a concise question related to the essay..." style="width:100%;padding:0.6rem;border-radius:8px;border:1px solid rgba(201,169,97,0.12);background:rgba(255,255,255,0.03);"></textarea>
                                    <div style="display:flex;gap:.5rem;align-items:center;margin-top:.5rem;">
                                      <button class="dc-ask paradox-button">Ask</button>
                                      <div class="dc-answer" style="flex:1;color:var(--text-secondary)"></div>
                                    </div>
                                  </div>
                                `;
                                modalBody.appendChild(qaWrap);

                                const questionEl = qaWrap.querySelector('.dc-question');
                                const askBtn = qaWrap.querySelector('.dc-ask');
                                const answerEl = qaWrap.querySelector('.dc-answer');

                                // store essay text for relevance checking
                                const essayPlain = (modalBody.textContent || '').slice(0, 20000);

                                askBtn.addEventListener('click', async () => {
                                    const q = (questionEl.value||'').trim();
                                    answerEl.textContent = '';
                                    if (!q) { answerEl.textContent = 'Please write a question.'; return; }

                                    // Automated relevance check using essay title and content
                                    answerEl.textContent = 'Checking if your question is related to the essay...';
                                    try {
                                        const isRelevant = await checkQuestionRelevance(q, item.title, essayPlain.slice(0, 2000));
                                        console.log(`Question relevance check: "${q}" for essay "${item.title}" -> ${isRelevant ? 'RELEVANT' : 'NOT RELEVANT'}`);
                                        if (!isRelevant) {
                                            answerEl.textContent = 'Please ask a question directly related to the essay content and themes.';
                                            return;
                                        }
                                    } catch (err) {
                                        console.warn('Relevance check failed, proceeding anyway:', err);
                                        // Proceed even if relevance check fails
                                    }

                                    // Build concise prompt with context
                                    const prompt = `You are a concise assistant. Answer the user's question about the provided ESSAY. Keep the answer short (one or two sentences) and directly relevant.\n\nESSAY:\n${essayPlain}\n\nQUESTION:\n${q}`;

                                    askBtn.disabled = true;
                                    const spinner = document.createElement('span');
                                    spinner.className = 'loading';
                                    answerEl.innerHTML = '';
                                    answerEl.appendChild(spinner);

                                        try {
                                            // Try OpenAI via proxy raw text
                                            let outText = null;
                                            try { outText = await callOpenAIRaw(prompt); } catch (e) { outText = null; }
                                            if (!outText) {
                                                try { outText = await callGeminiRaw(prompt); } catch (e) { outText = null; }
                                            }
                                            if (!outText) outText = 'Sorry — the assistant failed to produce an answer.';
                                            // sanitize and shorten
                                            outText = ('' + outText).trim();
                                            if (outText.length > 1000) outText = outText.slice(0,1000) + '...';
                                            answerEl.textContent = outText;
                                        } catch (e) {
                                            console.error('Q&A error', e);
                                            answerEl.textContent = 'An error occurred while fetching the answer.';
                                        } finally {
                                            askBtn.disabled = false;
                                        }
                                });
                            } catch (e) { console.error('Failed to attach QA', e); }
                        } catch (e) {
                            modalBody.textContent = 'Failed to load essay.';
                            console.error(e);
                        }
                    });
                    container.appendChild(card);
                });
            }

            closeBtn.addEventListener('click', () => modal.classList.remove('active'));
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.classList.remove('active');
            });
        }
        // ==== Diversity controls ====
        const DIVERSITY = {
          storageKey: "pe_history_v1",
          maxHistory: 60,
          similarThreshold: 0.32,   // 0..1 (higher = more tolerant to similarity)
          maxAttempts: 3            // how many re-rolls before giving up
        };
        
        const STOPWORDS = new Set([
          "the","and","for","that","with","this","from","your","you","are","but","not","all","was","have","has",
          "she","his","her","its","our","their","who","what","when","where","why","how","into","over","under",
          "to","of","in","on","at","by","as","is","it","be","or","if","an","a","we","i"
        ]);
        
        // Things we’re bored of seeing every other click
        const BANNED_KEYWORDS = [
          "theseus", "trolley", "brain in a vat", "liar paradox", "sorites",
          "newcomb", "zeno", "grandfather paradox", "sleeping beauty"
        ];
        
        const THEME_BUCKETS = [
          { name: "Identity",    seeds: ["continuity vs matter", "role-based identity", "narrative self vs memory loss"]},
          { name: "Time",        seeds: ["presentism vs eternalism", "time loops and consent", "prediction changing the future"]},
          { name: "Knowledge",   seeds: ["Gettier-style luck", "private language", "explanation vs experience"]},
          { name: "Ethics",      seeds: ["dirty-hands governance", "supererogation", "role morality vs impartiality"]},
          { name: "Agency",      seeds: ["precommitment & identity", "akrasia (weakness of will)", "self-editing desires"]},
          { name: "Logic",       seeds: ["reference without liar", "vagueness without heaps", "self-reference in laws"]},
          { name: "Technology",  seeds: ["value lock-in", "reward hacking", "alignment tax vs innovation"]}
        ];
        
        function loadHistory() {
          try { return JSON.parse(localStorage.getItem(DIVERSITY.storageKey) || "[]"); }
          catch { return []; }
        }
        
        function saveToHistory(item) {
          let hist = loadHistory();
          hist.unshift({ title: item.title, body: item.body, ts: Date.now() });
          if (hist.length > DIVERSITY.maxHistory) hist = hist.slice(0, DIVERSITY.maxHistory);
          localStorage.setItem(DIVERSITY.storageKey, JSON.stringify(hist));
        }
        
        function tokenize(s) {
          return (s || "")
            .toLowerCase()
            .replace(/[^a-zA-Z\u0600-\u06FF0-9\s]/g, " ")
            .split(/\s+/)
            .filter(w => w && w.length > 2 && !STOPWORDS.has(w));
        }
        
        function jaccard(tokensA, tokensB) {
          const A = new Set(tokensA), B = new Set(tokensB);
          let inter = 0;
          for (const x of A) if (B.has(x)) inter++;
          const union = A.size + B.size - inter;
          return union ? inter / union : 0;
        }

        // Automated question relevance checker
        async function checkQuestionRelevance(question, essayTitle, essayContent) {
          const prompt = `You are a relevance checker. Determine if the QUESTION is directly related to the ESSAY based on its title and content. 

ESSAY TITLE: "${essayTitle}"

ESSAY CONTENT (excerpt): 
${essayContent}

QUESTION: "${question}"

Task: Is this question directly related to the essay's topic and content? Answer with only "YES" or "NO".

Guidelines:
- YES if the question asks about concepts, arguments, or themes discussed in the essay
- YES if the question relates to the essay's philosophical position or ideas
- NO if the question is about completely unrelated topics
- NO if the question is about general knowledge not discussed in this specific essay
- NO if the question is about the author's personal life (unless discussed in the essay)

Answer:`;

          try {
            const key = getClientKey('OPENAI_API_KEY');
            if (!key) {
              console.warn('No OpenAI key for relevance check, falling back to Gemini');
              // Fallback to Gemini
              const gemKey = getClientKey('GEMINI_API_KEY');
              if (!gemKey) return true; // If no API keys, allow question
              
              const body = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                generationConfig: { temperature: 0.1, maxOutputTokens: 10 }
              };
              
              const res = await fetch(`https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent?key=${encodeURIComponent(gemKey)}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
              });
              
              if (!res.ok) return true; // If API fails, allow question
              const data = await res.json();
              const text = (data?.candidates?.[0]?.content?.parts || []).map(p => p.text || "").join("").trim().toUpperCase();
              return text.includes('YES');
            }

            // Use OpenAI for relevance check
            const body = {
              model: "gpt-4o-mini",
              messages: [{ role: "user", content: prompt }],
              temperature: 0.1,
              max_tokens: 10
            };

            const res = await fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + key
              },
              body: JSON.stringify(body)
            });

            if (!res.ok) return true; // If API fails, allow question
            const data = await res.json();
            const answer = (data?.choices?.[0]?.message?.content || "").trim().toUpperCase();
            return answer.includes('YES');
          } catch (err) {
            console.warn('Relevance check error:', err);
            return true; // If error, allow question
          }
        }
        
        function isTooSimilar(candidate, history) {
          const text = (candidate.title + " " + candidate.body);
          const candTok = tokenize(text);
          const bannedHit = BANNED_KEYWORDS.some(k => text.toLowerCase().includes(k));
          if (bannedHit) return true;
        
          // Compare against the last 12 pieces
          const recent = history.slice(0, 12);
          for (const h of recent) {
            const sim = jaccard(candTok, tokenize(h.title + " " + h.body));
            if (sim >= DIVERSITY.similarThreshold) return true;
          }
          return false;
        }
        
        function pickTheme() {
          return THEME_BUCKETS[Math.floor(Math.random() * THEME_BUCKETS.length)];
        }
        
        function pickSeedPair(theme) {
          const list = theme.seeds || [];
          if (list.length <= 1) return list;
          const i = Math.floor(Math.random() * list.length);
          let j = Math.floor(Math.random() * list.length);
          if (j === i) j = (j + 1) % list.length;
          return [list[i], list[j]];
        }

        // Enhanced Paradox with Separate Complexity and Abstraction
        function initEnhancedParadox() {
            const generateBtn = document.getElementById('generate-paradox');
            const outputDiv = document.getElementById('paradox-output');
            const titleEl = outputDiv.querySelector('.paradox-title');
            const contentEl = outputDiv.querySelector('.paradox-content');
        
            const complexitySlider = document.getElementById('complexity-slider');
            const abstractionSlider = document.getElementById('abstraction-slider');
            const complexityValue = document.getElementById('complexity-value');
            const abstractionValue = document.getElementById('abstraction-value');
        
            let currentMode = 'paradox';
        
            // 1) Put your Gemini API key here
            // Gemini key: removed hardcoded secret. If you host on GitHub Pages
            // and want client-side Gemini fallback, paste the key in the Settings panel.
            /* Gemini key is supplied by user via Settings (sessionStorage) */
        
            // 2) Map sliders to sampler config
            function mapComplexityToConfig(c, a) {
                const temperature = Math.min(1, 0.2 + (c + a) * 0.08);
                const maxOutputTokens = 400 + (c * 120);
                const topP = Math.min(0.98, 0.9 + (a * 0.02));
                return { temperature, topP, maxOutputTokens };
            }
        
            // 3) Precise JSON-only prompt
            function buildPrompt(mode, c, a) {
              const hist = loadHistory();
              const recentTitles = hist.slice(0, 8).map(h => h.title).join(" | ") || "—";
              const theme = pickTheme();
              const seeds = pickSeedPair(theme);
            
              return `
            You are ParadoxEngine, a concise, elegant philosophical content generator for a website.
            Produce a single piece according to MODE, COMPLEXITY, and ABSTRACTION, emphasizing novelty.
            
            MODE (exactly one of):
            - "paradox": present a classic or original paradox with 2–3 crisp tensions.
            - "dilemma": an ethical scenario with competing values and no trivial resolution.
            - "thought": a thought experiment that alters one premise of reality.
            - "dialogue": a short Socratic dialogue (8–12 lines, alternating "A:" / "B:").
            
            COMPLEXITY (1–5):
            - 1 = simple, intuitive; 5 = layered, multi-perspective, includes a counterpoint.
            
            ABSTRACTION (1–5):
            - 1 = concrete examples; 5 = highly abstract, conceptual.
            
            STYLE:
            - 1–2 sentence title (striking, no clickbait).
            - Body: ~150–230 words (for "dialogue", 8–12 terse exchanges).
            - Tone: lucid, precise, graceful; no clichés; no fluff.
            - Avoid moralizing; present tensions clearly.
            - No external references or markdown.
            
            NOVELTY CONSTRAINTS:
            - Do NOT repeat or paraphrase RECENT_TITLES.
            - Avoid well-worn clichés unless radically reframed: ${BANNED_KEYWORDS.join(", ")}.
            - Aim for the THEME and SEEDS subtly woven in (do not name them as labels).
            
            THEME: ${theme.name}
            SEEDS: ${seeds.join(", ") || "—"}
            RECENT_TITLES: ${recentTitles}
            
            THOUGHT QUESTIONS:
            Return 3–5 short, open-ended questions that provoke reflection.
            
            OUTPUT FORMAT (STRICT):
            Return ONLY valid JSON (no extra text, no markdown fences). Use this schema:
            {
              "title": "string",
              "body": "string",
              "questions": ["string", "string", ...]
            }
            
            INPUT:
            MODE="${mode}"
            COMPLEXITY=${c}
            ABSTRACTION=${a}
            `.trim();
            }

        
            // 4) JSON extractor (in case the model adds stray text)
            function extractJson(text) {
                  // 1) direct
                  try { return JSON.parse(text); } catch {}
                  // 2) ```json ... ``` or ```
                  const fence = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/i);
                  if (fence) { try { return JSON.parse(fence[1]); } catch {} }
                  // 3) largest {...}
                  const a = text.indexOf("{"), b = text.lastIndexOf("}");
                  if (a !== -1 && b !== -1 && b > a) {
                    try { return JSON.parse(text.slice(a, b + 1)); } catch {}
                  }
                  return null;
                }
                
                async function generateWithGemini(mode, c, a) {
                  const { temperature, topP, maxOutputTokens } = mapComplexityToConfig(c, a);
                
                // Use v1 + stable model name
                  const gemKey = getClientKey('GEMINI_API_KEY');
                  if (!gemKey) throw new Error('No Gemini key set');
                  const endpoint =
                    "https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent?key=" +
                    encodeURIComponent(gemKey);
                
                  const prompt = buildPrompt(mode, c, a);
                
                  const body = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { temperature, topP, maxOutputTokens },
                    // Make safety a bit less trigger-happy for philosophical content
                    safetySettings: [
                      { category: "HARM_CATEGORY_HARASSMENT",        threshold: "BLOCK_ONLY_HIGH" },
                      { category: "HARM_CATEGORY_HATE_SPEECH",       threshold: "BLOCK_ONLY_HIGH" },
                      { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                      { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
                    ]
                  };
                
                  let res;
                  try {
                    res = await fetch(endpoint, {
                      method: "POST",
                      headers: { "Content-Type": "application/json" },
                      body: JSON.stringify(body)
                    });
                  } catch (e) {
                    console.error("[Gemini] Network error:", e);
                    throw e;
                  }
                
                  if (!res.ok) {
                    let errBody;
                    try { errBody = await res.json(); } catch {}
                    console.error("[Gemini] HTTP", res.status, errBody || await res.text());
                    throw new Error("Gemini HTTP " + res.status);
                  }
                
                  const data = await res.json();
                  const cand = data?.candidates?.[0];
                  if (!cand) {
                    console.error("[Gemini] No candidates:", data);
                    throw new Error("No candidates");
                  }
                  if (cand.finishReason && cand.finishReason !== "STOP") {
                    console.warn("[Gemini] Finish reason:", cand.finishReason, data?.promptFeedback);
                    throw new Error("FinishReason=" + cand.finishReason);
                  }
                
                  // Some responses come split across multiple parts
                  const text = (cand.content?.parts || [])
                    .map(p => (p.text ?? ""))
                    .join("\n");
                
                  const json = extractJson(text);
                  if (!json || !json.title || !json.body || !Array.isArray(json.questions)) {
                    console.error("[Gemini] Invalid/Non-JSON response:", text);
                    throw new Error("Invalid JSON shape from Gemini");
                  }
                  return json;
                }

                async function generateWithOpenAI(mode, c, a) {
                  const { temperature, maxOutputTokens } = mapComplexityToConfig(c, a);
                
                  const key = getClientKey('OPENAI_API_KEY');
                  if (!key) throw new Error('No OpenAI API key set');
                
                  const prompt = buildPrompt(mode, c, a);
                
                  const body = {
                    model: "gpt-4o-mini",
                    messages: [{ role: "user", content: prompt }],
                    temperature,
                    max_tokens: maxOutputTokens,
                    response_format: { type: "json_object" }
                  };
                
                  let res;
                  try {
                    res = await fetch('https://api.openai.com/v1/chat/completions', {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + key
                      },
                      body: JSON.stringify(body)
                    });
                  } catch (e) {
                    console.error("[OpenAI] Network error:", e);
                    throw e;
                  }
                
                  if (!res.ok) {
                    let errBody;
                    try { errBody = await res.json(); } catch {}
                    console.error("[OpenAI] HTTP", res.status, errBody || await res.text());
                    throw new Error("OpenAI API error");
                  }
                
                  const data = await res.json();
                  const choice = data?.choices?.[0];
                  if (!choice) {
                    console.error("[OpenAI] No choices:", data);
                    throw new Error("No choices");
                  }
                
                  const text = choice.message?.content || "";
                  const json = extractJson(text);
                  if (!json || !json.title || !json.body || !Array.isArray(json.questions)) {
                    console.error("[OpenAI] Invalid/Non-JSON response:", text);
                    throw new Error("Invalid JSON shape from OpenAI");
                  }
                
                  return json;
                }

        
            // 6) Local fallback: shown if API fails
            const fallback = {
                paradox: [
                    {
                        title: "The Mirror That Remembers",
                        body: "A ship sails for a century; each plank is replaced. In a museum, artisans assemble the discarded planks. Which is Theseus’s ship? If identity lives in continuity, the sea-worn vessel wins. If identity lives in matter, the museum claims it. And if identity needs both, perhaps there was never a single ship—only overlapping histories we mistake for a thing.",
                        questions: [
                            "Where does identity ‘live’: function, matter, or memory?",
                            "If you forget a past self, are you less you?",
                            "What exactly is preserved when names persist?"
                        ]
                    }
                ],
                dilemma: [
                    {
                        title: "The Switch and the Bridge",
                        body: "A runaway train will kill five unless you pull a switch, diverting it toward one. Same numbers, but a second case asks you to push a man to stop it. If consequences alone decide, both acts align. If intentions and roles matter, the symmetry breaks—ethics lives where math and meaning quarrel.",
                        questions: [
                            "Do outcomes outweigh how those outcomes are produced?",
                            "Is omission morally different from action?",
                            "What role do norms about ‘using’ people play?"
                        ]
                    }
                ],
                thought: [
                    {
                        title: "Maria’s Room",
                        body: "Maria knows every physical fact about color but has never seen it. When she sees a red rose, does she learn something new? If yes, physics wasn’t complete; if no, experience seems redundant. Maybe we confuse describing a phenomenon from the outside with inhabiting it from within.",
                        questions: [
                            "Can a fact be knowable only by having it?",
                            "Is ‘what it’s like’ a distinct kind of information?",
                            "Does explanation require experience?"
                        ]
                    }
                ],
                dialogue: [
                    {
                        title: "On Freedom",
                        body: [
                            "A: I act freely when I get what I want.",
                            "B: Can you choose what you want to want?",
                            "A: I choose among my desires.",
                            "B: Chosen by what—another desire?",
                            "A: By me.",
                            "B: And what shapes that ‘me’?",
                            "A: History, habits, luck—",
                            "B: Then freedom is layered: choosing, and choosing the chooser.",
                            "A: Or owning the causes that own me.",
                            "B: A freedom that admits its chains."
                        ].join("\n"),
                        questions: [
                            "When do you feel most free—why?",
                            "Is authorship over desires required for freedom?",
                            "What would increasing freedom actually change?"
                        ]
                    }
                ]
            };
        
            function pickFallback(mode) {
                const arr = fallback[mode] || fallback.paradox;
                return arr[Math.floor(Math.random() * arr.length)];
            }
        
            // 7) Render helper
            function renderResult(result) {
                titleEl.textContent = result.title;
                contentEl.textContent = result.body;
        
                // Remove any previous questions block
                const old = outputDiv.querySelector('.paradox-questions');
                if (old) old.remove();
        
                // Add reflective questions under the content
                const qWrap = document.createElement('div');
                qWrap.className = 'paradox-questions';
                qWrap.innerHTML = `
                    <hr style="border:0;border-top:1px solid rgba(201,169,97,0.3);margin:1rem 0 .75rem;">
                    <div style="font-family: var(--font-display); font-size: var(--fs-small); color: var(--accent-gold); margin-bottom: .5rem;">
                        Questions to ponder
                    </div>
                `;
                const ul = document.createElement('ul');
                ul.style.listStyle = "disc";
                ul.style.margin = "0 0 0 1.25rem";
                ul.style.padding = "0";
                (result.questions || []).forEach(q => {
                    const li = document.createElement('li');
                    li.style.margin = ".35rem 0";
                    li.textContent = q;
                    ul.appendChild(li);
                });
                qWrap.appendChild(ul);
                outputDiv.appendChild(qWrap);
        
                outputDiv.classList.remove('hidden');
            }
        
            // 8) Wire up UI
            complexitySlider.addEventListener('input', (e) => {
                state.complexity = parseInt(e.target.value);
                complexityValue.textContent = state.complexity;
            });
            abstractionSlider.addEventListener('input', (e) => {
                state.abstraction = parseInt(e.target.value);
                abstractionValue.textContent = state.abstraction;
            });
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentMode = e.target.dataset.mode;
                });
            });
        
            // 9) Generate
            generateBtn.addEventListener('click', async () => {
              const c = state.complexity || 3;
              const a = state.abstraction || 3;
            
              console.log('Paradox Engine: Starting generation with', { mode: currentMode, complexity: c, abstraction: a });
              
              outputDiv.classList.remove('hidden');
              titleEl.textContent = `${currentMode.charAt(0).toUpperCase() + currentMode.slice(1)} (C:${c} A:${a})`;
              contentEl.innerHTML = `<div class="loading" aria-label="loading"></div>`;
            
              let result = null;
              let lastErr = null;
            
              for (let attempt = 1; attempt <= DIVERSITY.maxAttempts; attempt++) {
                try {
                  // Try OpenAI first
                  console.log(`[ParadoxEngine] Calling OpenAI API (attempt ${attempt})`);
                  const json = await generateWithOpenAI(currentMode, c, a);
                  console.log('[ParadoxEngine] Got OpenAI response:', json);
                  if (!isTooSimilar(json, loadHistory())) {
                    result = json;
                    break;
                  } else {
                    console.info(`[ParadoxEngine] Similar to history (attempt ${attempt}) → re-rolling`);
                  }
                } catch (openaiErr) {
                  console.warn("[ParadoxEngine] OpenAI failed:", openaiErr);
                  
                  // Fallback to Gemini
                  try {
                    console.log(`[ParadoxEngine] Falling back to Gemini API (attempt ${attempt})`);
                    const json = await generateWithGemini(currentMode, c, a);
                    console.log('[ParadoxEngine] Got Gemini response:', json);
                    if (!isTooSimilar(json, loadHistory())) {
                      result = json;
                      break;
                    } else {
                      console.info(`[ParadoxEngine] Gemini response similar to history (attempt ${attempt}) → re-rolling`);
                    }
                  } catch (geminiErr) {
                    lastErr = geminiErr;
                    console.error("[ParadoxEngine] Both APIs failed:", { openai: openaiErr, gemini: geminiErr });
                    break; // Both APIs failing → don't hammer them
                  }
                }
              }
            
              if (!result) {
                const fb = pickFallback(currentMode);
                result = fb;
              }
            
              renderResult(result);
              // Save even if it came from fallback, so the fallback variety also rotates
              saveToHistory(result);
            });

        }

        // Dark Radio with Original Design
        function initDarkRadio() {
            const powerBtn = document.getElementById('power-btn');
            const scanBtn = document.getElementById('scan-btn');
            const tunerKnob = document.getElementById('tuner-knob');
            const transcriptText = document.getElementById('transcript-text');
            const stationName = document.getElementById('station-name');
            const frequencyDisplay = document.getElementById('frequency-display');
            const frequencyMarker = document.getElementById('frequency-marker');
            const visualizerCanvas = document.getElementById('audio-visualizer');
            const ctx = visualizerCanvas.getContext('2d');
            let typeTimeout = null;
            let typeSession = 0;
            const stations = [
                { freq: 88.5, name: 'VOID.FM', type: 'Existential' },
                { freq: 90.3, name: 'ABYSS.FM', type: 'Nihilistic' },
                { freq: 92.1, name: 'SHADOW.FM', type: 'Psychological' },
                { freq: 94.7, name: 'DOOM.FM', type: 'Apocalyptic' },
                { freq: 96.6, name: 'HELL.FM', type: 'Infernal' },
                { freq: 98.9, name: 'DEATH.FM', type: 'Mortality' },
                { freq: 101.1, name: 'MADNESS.FM', type: 'Insanity' },
                { freq: 103.3, name: 'TRAUMA.FM', type: 'Memory' },
                { freq: 105.5, name: 'SILENCE.FM', type: 'Emptiness' },
                { freq: 107.7, name: 'END.FM', type: 'Finality' }
            ];
            
            const broadcasts = {
                'Existential': [
                    "You are a cosmic accident, a brief arrangement of atoms pretending to have meaning. The universe was fine without you for 14 billion years and won't notice when you're gone.",
                    "Free will is an illusion. Every thought you have is the result of prior causes stretching back to the Big Bang. You're a puppet who can see the strings but can't stop dancing.",
                    "Everyone you love will die. Some before you, leaving you to grieve. Some after you, and you'll abandon them to grief. Love is just setting yourself up for inevitable loss.",
                    "Your consciousness is a hallucination. The 'self' is just a story your brain tells itself. You don't exist in any meaningful way—you're just matter pretending to matter."
                ],
                'Nihilistic': [
                    "Nothing you do will be remembered in 1000 years. Your greatest achievements will be dust, your name forgotten, your impact erased. You're just killing time until time kills you.",
                    "Morality is a collective delusion. There's no cosmic judge, no karmic balance. The universe rewards cruelty as often as kindness. Ethics are just opinions with better PR.",
                    "Life has no inherent purpose. You weren't meant to be here. There's no plan, no destiny, no reason. You're a random fluctuation in entropy, signifying nothing.",
                    "Hope is the cruelest lie we tell ourselves. It keeps us suffering when we should surrender. The future will disappoint you just like the past did."
                ],
                'Psychological': [
                    "Your personality is just a trauma response that got comfortable. Every quirk you think makes you unique is actually damage you're too afraid to heal.",
                    "You're not as good a person as you think. Your brain rewrites memories to make you the hero. In someone else's story, you're the villain.",
                    "The voice in your head isn't you—it's an echo of everyone who ever hurt you. You're haunted by ghosts that use your mouth to speak.",
                    "Mental illness isn't a bug; it's a feature. Depression sees reality clearly. Anxiety predicts accurately. Sanity is just functional delusion."
                ],
                'Apocalyptic': [
                    "Civilization is three meals away from collapse. The thin veneer of order could shatter any moment. Beneath our civility lurks primordial violence.",
                    "Climate change is irreversible. We've already triggered feedback loops that will make Earth uninhabitable. You're living in the last days of a dying world.",
                    "Nuclear weapons still exist, thousands of them, waiting. One miscalculation, one malfunction, and everything ends in fire and radiation.",
                    "The next pandemic could be the last. Antibiotic resistance, bioweapons, or nature's next surprise—humanity's end might already be mutating somewhere."
                ],
                'Infernal': [
                    "Hell is other people, but worse—hell is yourself. You are your own eternal torment, trapped forever with the person you hate most: you.",
                    "Every comfort is built on someone else's suffering. Your clothes, food, technology—all made possible by exploitation you choose to ignore.",
                    "The worst part about evil is how ordinary it is. Monsters look like neighbors, smile like friends. Atrocity happens in daylight, documented and ignored.",
                    "You carry hell with you. It's in every regret, every shameful memory, every moment you failed to be who you pretended to be."
                ],
                'Mortality': [
                    "Your body is already dying. Each heartbeat is one fewer. Each breath brings you closer to your last. You're decomposing in slow motion.",
                    "The people you love are dying too. Some quickly, some slowly, all inevitably. Every goodbye could be the last, and you'll never know which one.",
                    "Immortality would be worse than death. Watching everyone you love die, experiencing heat death of the universe, floating alone in infinite darkness forever.",
                    "You won't know when you're dead. One moment you'll exist, the next you won't, with no experience of the transition. You'll never know your story's ending."
                ],
                'Insanity': [
                    "Madness is clarity. What you call sanity is just agreed-upon delusion. The mad see through the veil; that's why we lock them away.",
                    "You can't trust your own mind. Memory lies, perception deceives, reasoning fails. You're trapped in a brain you can't escape and can't rely on.",
                    "Everyone is insane in their own way. We just hide it better than those we institutionalize. Normalcy is performed madness.",
                    "The line between genius and madness is drawn by the mediocre. What we can't understand, we pathologize. Today's madness is tomorrow's breakthrough."
                ],
                'Memory': [
                    "Your past is fiction. Every time you remember, you rewrite the memory. You're nostalgic for events that never happened the way you remember them.",
                    "Trauma rewrites your neural pathways. You're physically scarred by what happened to you. Your brain is a monument to everything that hurt you.",
                    "You'll forget almost everything. The moments you swear you'll remember forever will fade. Your life will compress into a few vague impressions.",
                    "The people who remember you will die, and then you'll be truly gone. First your body, then the memories of you. Complete erasure is coming."
                ],
                'Emptiness': [
                    "Between thoughts is void. Between heartbeats is death. You're mostly empty space pretending to be solid, mostly nothing pretending to be something.",
                    "Silence isn't peaceful—it's the sound of absence. In true quiet, you hear the nothing that waits to reclaim everything.",
                    "The void doesn't stare back—it swallows. You've been falling into it since birth. Everything you do is just distraction from the emptiness.",
                    "Connection is impossible. We're all locked in our own skulls, guessing at what others feel. Every relationship is two people alone together."
                ],
                'Finality': [
                    "There are no second chances. Every moment you waste is gone forever. Every opportunity missed is permanently lost. Time only moves forward.",
                    "Endings don't care if you're ready. Death, loss, failure—they come when they come. Closure is a myth; most things end badly and suddenly.",
                    "The last time is never marked. You've already done thousands of things for the last time without knowing it. The final anything rarely announces itself.",
                    "Everything ends. Every civilization, every star, every atom will decay. The universe itself will end in heat death. Nothing escapes entropy."
                ]
            };
            
            let isDragging = false;
            let startAngle = 0;
            let currentAngle = 0;
            
            function findNearestStation(freq) {
                return stations.reduce((nearest, station) => {
                    const nearestDiff = Math.abs(nearest.freq - freq);
                    const stationDiff = Math.abs(station.freq - freq);
                    return stationDiff < nearestDiff ? station : nearest;
                });
            }
            
            function tuneToFrequency(freq) {
              state.currentFrequency = freq;
              frequencyDisplay.textContent = freq.toFixed(1);
              frequencyMarker.style.left = `${((freq - 88) / 20) * 100}%`;
            
              const station = stations.find(s => Math.abs(s.freq - freq) < 0.5);
            
              if (station && state.isPowered) {
                if (!state.currentStation || state.currentStation.name !== station.name) {
                  stationName.textContent = station.name;
                  state.currentStation = station;
            
                  const messages = broadcasts[station.type];
                  const message = messages[Math.floor(Math.random() * messages.length)];
                  typeMessage(message);
                }
              } else if (state.isPowered) {
                stationName.textContent = 'STATIC';
                state.currentStation = null;
                transcriptText.textContent = '*static* .searching for signal in the darkness.';
              }
            }

            
            function typeMessage(text) {
              typeSession++;                    // new session id
              const mySession = typeSession;
            
              if (typeTimeout) {                // cancel any previous tick
                clearTimeout(typeTimeout);
                typeTimeout = null;
              }
            
              transcriptText.textContent = '';
              let i = 0;
            
              const tick = () => {
                // abort if a new session started or radio got powered off
                if (mySession !== typeSession || !state.isPowered) return;
            
                if (i < text.length) {
                  transcriptText.textContent += text[i++];
                  typeTimeout = setTimeout(tick, 30 + Math.random() * 50);
                }
              };
              tick();
            }

            
            // Visualizer
            function animateVisualizer() {
                visualizerCanvas.width = visualizerCanvas.offsetWidth;
                visualizerCanvas.height = visualizerCanvas.offsetHeight;
                
                function draw() {
                    ctx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                    
                    if (state.isPowered) {
                        const bars = 32;
                        const barWidth = visualizerCanvas.width / bars;
                        
                        for (let i = 0; i < bars; i++) {
                            const height = Math.random() * visualizerCanvas.height * 0.7;
                            const x = i * barWidth;
                            const y = visualizerCanvas.height - height;
                            
                            const gradient = ctx.createLinearGradient(0, y, 0, visualizerCanvas.height);
                            gradient.addColorStop(0, 'rgba(201, 169, 97, 0.8)');
                            gradient.addColorStop(1, 'rgba(201, 169, 97, 0.2)');
                            
                            ctx.fillStyle = gradient;
                            ctx.fillRect(x, y, barWidth - 2, height);
                        }
                    }
                    
                    requestAnimationFrame(draw);
                }
                draw();
            }
            
            powerBtn.addEventListener('click', () => {
                state.isPowered = !state.isPowered;
                powerBtn.classList.toggle('active');
                
                if (!state.isPowered) {
                    transcriptText.textContent = '*powered off*';
                    stationName.textContent = '---';
                    frequencyDisplay.textContent = '---';
                } else {
                    tuneToFrequency(state.currentFrequency);
                }
            });
            
            scanBtn.addEventListener('click', () => {
                if (!state.isPowered) return;
                
                let scanning = true;
                let scanCount = 0;
                const scanInterval = setInterval(() => {
                    const randomFreq = 88 + Math.random() * 20;
                    frequencyDisplay.textContent = randomFreq.toFixed(1);
                    frequencyMarker.style.left = `${((randomFreq - 88) / 20) * 100}%`;
                    
                    scanCount++;
                    if (scanCount > 10) {
                        clearInterval(scanInterval);
                        const randomStation = stations[Math.floor(Math.random() * stations.length)];
                        tuneToFrequency(randomStation.freq);
                    }
                }, 100);
            });
            
            // Tuner knob control
            tunerKnob.addEventListener('mousedown', (e) => {
                if (!state.isPowered) return;
                isDragging = true;
                const rect = tunerKnob.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                startAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const rect = tunerKnob.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                const deltaAngle = angle - startAngle;
                currentAngle += deltaAngle;
                startAngle = angle;
                
                tunerKnob.style.transform = `rotate(${currentAngle}rad)`;
                
                const freqDelta = deltaAngle * 5;
                const newFreq = Math.max(88, Math.min(108, state.currentFrequency + freqDelta));
                tuneToFrequency(newFreq);
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    // Snap to nearest station
                    const nearest = findNearestStation(state.currentFrequency);
                    tuneToFrequency(nearest.freq);
                }
            });
            
            animateVisualizer();
        }

        function initFloatingParticles() {
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.cssText = `width:${Math.random()*4+1}px;height:${Math.random()*4+1}px;background:var(--accent-gold);left:${Math.random()*window.innerWidth}px;animation-duration:${Math.random()*20+20}s;animation-delay:${Math.random()*20}s`;
                document.body.appendChild(particle);
            }
        }

        // === Global Utility Functions ===
        // Config
        const OPENAI_MODEL = "gpt-4o";
        
        // Read PROXY_BASE_URL from a meta tag or a preset global `window.PROXY_BASE_URL`
          const PROXY_BASE_URL = (function(){
          try {
            if (window.PROXY_BASE_URL) return window.PROXY_BASE_URL.replace(/\/$/, '');
            const m = document.querySelector('meta[name="proxy-base-url"]');
            if (m && m.content) return m.content.trim().replace(/\/$/, '');
          } catch (e) {}
          return '';
          })();

          const OPENAI_KEY_PARTS = [ "sk-proj-8aBRMVJVk_e5nCOje", "A4FQTAj0e3YTwj1bLJUzLI3xol4yGj5I5Z8GF4L", "XLr5jiAqUAgciAL1XOT3BlbkFJO-blJBCp2hQS3OZdVliY13pG-ai39qhCPJ", "-_iLplRqKtBOtK8wGeJM9h0EAbS5njxACmxxAAsA" ];
          const GEMINI_KEY_PARTS = ["AIzaSyAqXYggfgL", "t5_dL6wLEkNZUnGXr5QHBch4"];
          const TMDB_KEY_PARTS   = [ "4511961cbe3d628", "1498c1923f1234eac" ];

          // Assembled constants (empty if no parts provided)
          const OPENAI_API_KEY = (Array.isArray(OPENAI_KEY_PARTS) && OPENAI_KEY_PARTS.length)? OPENAI_KEY_PARTS.join('') : '';
          const GEMINI_API_KEY = (Array.isArray(GEMINI_KEY_PARTS) && GEMINI_KEY_PARTS.length)? GEMINI_KEY_PARTS.join('') : '';
          const TMDB_API_KEY   = (Array.isArray(TMDB_KEY_PARTS)   && TMDB_KEY_PARTS.length)?   TMDB_KEY_PARTS.join('')   : '';

          // Helper to get client-side keys stored by the user in the settings panel
          // This will prefer assembled constants embedded in the page, then fall back to sessionStorage parts.
          function getClientKey(name){
            try {
              // Prefer constants embedded directly in the code (assembled from parts above)
              if (name === 'OPENAI_API_KEY' && typeof OPENAI_API_KEY !== 'undefined' && OPENAI_API_KEY) return OPENAI_API_KEY;
              if (name === 'GEMINI_API_KEY' && typeof GEMINI_API_KEY !== 'undefined' && GEMINI_API_KEY) return GEMINI_API_KEY;
              if (name === 'TMDB_API_KEY' && typeof TMDB_API_KEY !== 'undefined' && TMDB_API_KEY) return TMDB_API_KEY;

              // Otherwise, try sessionStorage parts or legacy single key
              if (name === 'OPENAI_API_KEY'){
                try { const parts = sessionStorage.getItem('OPENAI_KEY_PARTS'); if (parts) return JSON.parse(parts).join(''); } catch {}
                return sessionStorage.getItem('OPENAI_API_KEY') || '';
              }
              if (name === 'GEMINI_API_KEY'){
                try { const parts = sessionStorage.getItem('GEMINI_KEY_PARTS'); if (parts) return JSON.parse(parts).join(''); } catch {}
                return sessionStorage.getItem('GEMINI_API_KEY') || '';
              }
              if (name === 'TMDB_API_KEY'){
                try { const parts = sessionStorage.getItem('TMDB_KEY_PARTS'); if (parts) return JSON.parse(parts).join(''); } catch {}
                return sessionStorage.getItem('TMDB_API_KEY') || '';
              }

              return sessionStorage.getItem(name) || '';
            } catch { return ''; }
          }

        async function callOpenAI(prompt) {
          // Build chat-completions body
          const body = {
            model: OPENAI_MODEL,
            temperature: 0.7,
            top_p: 0.95,
            max_tokens: 700,
            messages: [
              { role: "system", content: "You are a helpful assistant that returns valid JSON when requested." },
              { role: "user", content: prompt }
            ]
          };

          if (PROXY_BASE_URL) {
            const url = PROXY_BASE_URL + '/api/doublecrux';
            const res = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(body)
            });
            if (!res.ok) throw new Error('Proxy HTTP ' + res.status);
            const data = await res.json();
            const text = data?.choices?.[0]?.message?.content || '';
            return parseJsonStrict(text);
          } else {
            const key = getClientKey('OPENAI_API_KEY');
            if (!key) throw new Error('No OpenAI API key set (paste it in Settings)');
            const res = await fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + key
              },
              body: JSON.stringify(body)
            });
            if (!res.ok) throw new Error('OpenAI HTTP ' + res.status);
            const data = await res.json();
            const text = data?.choices?.[0]?.message?.content || '';
            return parseJsonStrict(text);
          }
        }

        // Raw-text version for short-answer Q&A: returns plain string
        async function callOpenAIRaw(prompt) {
          const body = {
            model: OPENAI_MODEL,
            temperature: 0.3,
            top_p: 0.9,
            max_tokens: 180,
            messages: [
              { role: "system", content: "You are a concise assistant that answers questions briefly and directly." },
              { role: "user", content: prompt }
            ]
          };

          // If a proxy is configured, use it; otherwise call OpenAI directly using sessionStorage key
          if (PROXY_BASE_URL) {
            const url = PROXY_BASE_URL + '/api/doublecrux';
            const res = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(body)
            });
            if (!res.ok) throw new Error('Proxy HTTP ' + res.status);
            const data = await res.json();
            return data?.choices?.[0]?.message?.content || '';
          } else {
            const key = getClientKey('OPENAI_API_KEY');
            if (!key) throw new Error('No OpenAI API key set (paste it in Settings)');
            const res = await fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + key
              },
              body: JSON.stringify(body)
            });
            if (!res.ok) throw new Error('OpenAI HTTP ' + res.status);
            const data = await res.json();
            return data?.choices?.[0]?.message?.content || '';
          }
        }

        // Gemini raw response helper
        async function callGeminiRaw(prompt) {
          const key = getClientKey('GEMINI_API_KEY');
          if (!key) throw new Error('No Gemini API key set');
          const endpoint = "https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent?key=" + encodeURIComponent(key);
          const body = {
            contents: [{ role: "user", parts: [{ text: prompt }] }],
            generationConfig: { temperature: 0.3, topP: 0.9, maxOutputTokens: 500 },
            safetySettings: []
          };
          const res = await fetch(endpoint, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
          if (!res.ok) throw new Error("Gemini HTTP " + res.status);
          const data = await res.json();
          const text = (data?.candidates?.[0]?.content?.parts || []).map(p => p.text || "").join("\n");
          return text;
        }

        // JSON parsing helper
        function parseJsonStrict(text) {
          try {
            return JSON.parse(text);
          } catch (e) {
            // Try to extract JSON from text if it's wrapped in other content
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
              return JSON.parse(jsonMatch[0]);
            }
            throw new Error('Invalid JSON: ' + text);
          }
        }

        function initDoubleCruxStudio() {
          const el = {
            input:  document.getElementById('dc-input'),
            rigor:  document.getElementById('dc-rigor'),
            abstr:  document.getElementById('dc-abstr'),
            formal: document.getElementById('dc-formal'),
            run:    document.getElementById('dc-run'),
            out:    document.getElementById('dc-output'),
            tldr:   document.getElementById('dc-tldr'),
            cards:  document.getElementById('dc-cards'),
          };
        
          // === Lightweight anti-repeat memory ===
          const DC_MEM = { key: "dc_history_v1", max: 40, sim: 0.30, attempts: 3 };
          const STOP = new Set(["the","and","for","that","with","this","from","your","you","are","but","not","all","was","have","has","to","of","in","on","at","by","as","is","it","be","or","if","an","a","we","i"]);
        
          function memLoad() { try { return JSON.parse(localStorage.getItem(DC_MEM.key) || "[]"); } catch { return []; } }
          function memSave(item) {
            let h = memLoad();
            h.unshift({ claim: item.claim, tldr: item.tldr, ts: Date.now() });
            if (h.length > DC_MEM.max) h = h.slice(0, DC_MEM.max);
            localStorage.setItem(DC_MEM.key, JSON.stringify(h));
          }
          function tok(s){ return (s||"").toLowerCase().replace(/[^a-z0-9\u0600-\u06FF\s]/g," ").split(/\s+/).filter(w=>w && w.length>2 && !STOP.has(w)); }
          function jac(a,b){ const A=new Set(a),B=new Set(b); let i=0; for(const x of A) if(B.has(x)) i++; const u=A.size+B.size-i; return u? i/u : 0; }
        
          // === Prompt builder (strict JSON) ===
          function buildPrompt({claim, rigor, abstr, formal}) {
            const rec = memLoad().slice(0, 6).map(x => x.tldr).join(" | ") || "—";
            const tone = formal ? "formal, quasi-academic" : "plain, precise";
            return `
        You are DoubleCrux. Deconstruct the user's CLAIM rigorously.
        
        Return ONLY valid JSON (no markdown, no prose pre/post). Schema:
        {
          "steelman": ["..."],
          "strongest_objections": ["..."],
          "cruxes": ["..."],
          "decisive_evidence": ["..."],
          "failure_modes": ["..."],
          "tldr": "..."
        }
        
        Constraints:
        - RIGOR: ${rigor}/5 (1=light intuition, 5=tight, quasi-formal).
        - ABSTRACTION: ${abstr}/5 (1=concrete examples, 5=conceptual).
        - Tone: ${tone}. Neutral; do not predict the future; no moralizing; ≤16 words per bullet.
        - Each crux should be a potential mind-changer if resolved; evidence are concrete tests/measurements.
        - Avoid clichés and repeated phrasing from RECENT_TLDRS: ${rec}
        
        CLAIM: "${claim}"
        `.trim();
          }

          // === Use global functions - removed duplicates ===
          
          // === Gemini fallback ===
          async function callGemini(prompt) {
            const key = getClientKey('GEMINI_API_KEY');
            if (!key) throw new Error('No Gemini key set');
            const endpoint = "https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent?key=" + encodeURIComponent(key);
            const body = {
              contents: [{ role: "user", parts: [{ text: prompt }] }],
              generationConfig: { temperature: 0.8, topP: 0.95, maxOutputTokens: 650, responseMimeType: "application/json" },
              safetySettings: [
                { category: "HARM_CATEGORY_HARASSMENT",        threshold: "BLOCK_ONLY_HIGH" },
                { category: "HARM_CATEGORY_HATE_SPEECH",       threshold: "BLOCK_ONLY_HIGH" },
                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
              ]
            };
            const res = await fetch(endpoint, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
            if (!res.ok) throw new Error("Gemini HTTP " + res.status);
            const data = await res.json();
            const text = (data?.candidates?.[0]?.content?.parts || []).map(p => p.text || "").join("\n");
            return parseJsonLoose(text);
          }

          // Gemini raw response helper
          async function callGeminiRaw(prompt) {
            const key = getClientKey('GEMINI_API_KEY');
            if (!key) throw new Error('No Gemini API key set');
            const endpoint = "https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent?key=" + encodeURIComponent(key);
            const body = {
              contents: [{ role: "user", parts: [{ text: prompt }] }],
              generationConfig: { temperature: 0.3, topP: 0.9, maxOutputTokens: 300 },
              safetySettings: []
            };
            const res = await fetch(endpoint, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
            if (!res.ok) throw new Error("Gemini HTTP " + res.status);
            const data = await res.json();
            const text = (data?.candidates?.[0]?.content?.parts || []).map(p => p.text || "").join("\n");
            return text;
          }
        
          // === Parsers ===
          function parseJsonStrict(s){ return JSON.parse(s); }
          function parseJsonLoose(s){
            try { return JSON.parse(s); } catch {}
            const fence = s.match(/```(?:json)?\s*([\s\S]*?)\s*```/i);
            if (fence) { try { return JSON.parse(fence[1]); } catch {} }
            const a = s.indexOf("{"), b = s.lastIndexOf("}");
            if (a!==-1 && b!==-1 && b>a) { try { return JSON.parse(s.slice(a,b+1)); } catch {} }
            throw new Error("Invalid JSON");
          }

          // === Enhanced claim detector ===
          // Heuristic: reject obvious questions or very short inputs as non-claims.
          function isLikelyClaim(text){
            if (!text || typeof text !== 'string') return false;
            const t = text.trim();
            if (t.length < 10) return false; // too short to be a meaningful claim
            if (t.includes('?')) return false; // questions are not claims
            
            // Common question starters
            const qStarters = /^(who|what|when|where|why|how|does|do|did|is|are|am|should|could|would|can|will|please|help|explain|tell)\b/i;
            if (qStarters.test(t)) return false;
            
            // Imperative sentences (commands) are not claims
            const imperatives = /^(go|make|create|build|write|give|show|tell|explain|help|please)\b/i;
            if (imperatives.test(t)) return false;
            
            // Must have some structure (subject + predicate indicators)
            const hasVerb = /\b(is|are|was|were|will|would|can|could|should|has|have|had|does|do|did|makes|made|causes|leads|results|means|indicates|suggests|proves|shows|demonstrates)\b/i;
            if (!hasVerb.test(t)) return false;
            
            return true;
          }
        
          // === Local fallback (short, clean) ===
          const FALLBACKS = [
            {
              tldr: "Openness can aid safety, but increases capability diffusion risks.",
              steelman: [
                "Peer review exposes flaws sooner",
                "Wider scrutiny reduces single-point failure",
                "Transparency builds trust and adoption"
              ],
              strongest_objections: [
                "Capability leakage to bad actors",
                "Racing dynamics worsen with easy replication",
                "Misuse externalities aren’t borne by publishers"
              ],
              cruxes: [
                "Does openness demonstrably accelerate misuse vs. defense?",
                "Can governance internalize externalities of release?"
              ],
              decisive_evidence: [
                "Misuse incident rates pre/post open releases",
                "Benchmark deltas for red-team vs. threat actors"
              ],
              failure_modes: [
                "Equating transparency with responsibility",
                "Ignoring incentives and deployment context"
              ]
            },
            {
              tldr: "Privacy erosion is not destiny; it’s an incentive and standards problem.",
              steelman: [
                "Network effects reward data hoarding",
                "Users trade privacy for convenience",
                "Enforcement is costly and slow"
              ],
              strongest_objections: [
                "Market demand for privacy tech is rising",
                "Regulatory fines change incentives",
                "Privacy-preserving ML is improving"
              ],
              cruxes: [
                "Do fines exceed data-extraction profits?",
                "Can UX match convenience without tracking?"
              ],
              decisive_evidence: [
                "Profit impact of major fines",
                "Adoption of PP-ML with equivalent UX"
              ],
              failure_modes: [
                "Treating ‘privacy’ as binary",
                "Underestimating product friction"
              ]
            }
          ];
        
          function pickFallback() {
            return JSON.parse(JSON.stringify(FALLBACKS[Math.floor(Math.random()*FALLBACKS.length)]));
          }
        
          // === Similarity guard on TL;DR ===
          function tooSimilar(tldr){
            const hist = memLoad().slice(0, 10);
            const cand = tok(tldr);
            return hist.some(h => jac(cand, tok(h.tldr)) >= DC_MEM.sim);
          }
        
          // === Render ===
          function render(result, claim){
            el.tldr.textContent = result.tldr || "Deconstruction";
            const mk = (title, items) => `
              <div class="glass" style="padding:1rem;border-radius:14px;margin:.75rem 0;">
                <div class="mono" style="color:var(--accent-gold);margin-bottom:.25rem">${title}</div>
                <ul style="margin:.25rem 0 0 1rem;line-height:1.8;">${
                  (items||[]).map(x=>`<li>${escapeHtml(x)}</li>`).join("")
                }</ul>
              </div>`;
            el.cards.innerHTML =
              mk("Steelman", result.steelman) +
              mk("Strongest objections", result.strongest_objections) +
              mk("Cruxes (mind-changers)", result.cruxes) +
              mk("Decisive evidence (tests)", result.decisive_evidence) +
              mk("Failure modes", result.failure_modes);
        
            el.out.classList.remove('hidden');
            memSave({ claim, tldr: result.tldr || claim.slice(0,60) });
          }
        
        
          // === Wire up button ===
          el.run.addEventListener('click', async () => {
            const claim = (el.input.value || "").trim();
            if (!claim) {
              el.out.classList.remove('hidden');
              el.tldr.textContent = "Give me a claim to dissect.";
              el.cards.innerHTML = "";
              return;
            }

            // Quick claim validation: ensure it's likely a declarative claim
            if (!isLikelyClaim(claim)) {
              el.out.classList.remove('hidden');
              el.tldr.textContent = "Please enter a clear CLAIM (a declarative statement that can be true or false). Avoid questions, commands, or very short text. Example: 'Climate change is primarily caused by human activities.'";
              el.cards.innerHTML = "";
              return;
            }
            el.out.classList.remove('hidden');
            el.tldr.textContent = "Deconstructing…";
            el.cards.innerHTML = `<div class="loading" aria-label="loading"></div>`;
        
            let result = null, lastErr = null;
            const config = { claim, rigor: +el.rigor.value || 3, abstr: +el.abstr.value || 3, formal: !!el.formal.checked };
        
            for (let attempt=1; attempt<=DC_MEM.attempts; attempt++) {
              const prompt = buildPrompt(config);
              try {
                // Prefer OpenAI; fallback to Gemini; then local
                const cand = await callOpenAI(prompt).catch(async e => { lastErr=e; return await callGemini(prompt); });
                if (!cand || !cand.tldr) throw new Error("Bad JSON");
                if (!tooSimilar(cand.tldr)) { result = cand; break; }
                console.info(`[Double-Crux] Similar phrasing (attempt ${attempt}) → re-roll`);
              } catch (e) {
                lastErr = e;
                break; // don’t hammer if APIs are failing
              }
            }
            if (!result) result = pickFallback();
            // Attach claim for memory
            result.claim = claim;
            render(result, claim);
          });
        }

        // Movies functionality - defined after utility functions
        function initMovies(){
            const suggestBtn = document.getElementById('movie-suggest');
            const status = document.getElementById('movie-status');
            const results = document.getElementById('movie-results');
            const ratingSlider = document.getElementById('movie-min-rating');
            const ratingDisplay = document.getElementById('rating-display');

            // Local robust JSON parser used for LLM outputs
            function parseJsonLooseLocal(s){
                if (!s || typeof s !== 'string') return null;
                // 1) direct parse
                try { return JSON.parse(s); } catch(e) {}
                // 2) fenced ```json blocks
                try {
                    const fence = s.match(/```(?:json)?\s*([\s\S]*?)\s*```/i);
                    if (fence) { try { return JSON.parse(fence[1]); } catch(e){} }
                } catch(e){}
                // 3) find largest [ ... ] block
                try {
                    let best = null;
                    let a = s.indexOf('[');
                    while (a !== -1) {
                        const b = s.indexOf(']', a+1);
                        if (b === -1) break;
                        const cand = s.slice(a, b+1);
                        try { const j = JSON.parse(cand); if (Array.isArray(j)) { if (!best || cand.length > best.length) best = j; } } catch(e) {}
                        a = s.indexOf('[', a+1);
                    }
                    if (best) return best;
                } catch(e){}
                return null;
            }

            // Update rating display when slider changes
            ratingSlider.addEventListener('input', (e) => {
                ratingDisplay.textContent = parseFloat(e.target.value).toFixed(1);
            });

            suggestBtn.addEventListener('click', async ()=>{
                status.textContent = '';
                results.innerHTML = '';
                const mood = document.getElementById('movie-mood').value;
                const era = document.getElementById('movie-era').value;
                const lang = document.getElementById('movie-lang').value;
                const minRating = document.getElementById('movie-min-rating').value;

                status.textContent = 'Searching for perfect films...';
                suggestBtn.disabled = true;
                results.innerHTML = '<div style="text-align:center;padding:2rem;color:var(--text-secondary)" class="mono">Curating recommendations...</div>';

                const criteria = { mood, era, lang, minRating };
                const prompt = buildMoviePrompt(criteria);

                let list = null;
                let apiError = false;
                
                try {
                    status.textContent = 'Consulting film curator...';
                    const response = await callOpenAIRaw(prompt + "\nRETURN_JSON: true");
                    // Try to parse robustly using local parser (supports fences, partials)
                    try {
                        const parsed = parseJsonLooseLocal(response);
                        if (Array.isArray(parsed)) list = parsed;
                        else if (Array.isArray(parsed?.movies)) list = parsed.movies;
                        else list = null;
                    } catch (e) {
                        console.warn('LLM returned non-JSON or unexpected shape for movies:', e, response);
                        list = null;
                    }
                    // If parse failed, attempt to find largest array substring as a last resort
                    if (!list) {
                        try {
                            const a = response.indexOf('['), b = response.lastIndexOf(']');
                            if (a !== -1 && b !== -1) {
                                const cand = response.slice(a, b+1);
                                try { const j = JSON.parse(cand); if (Array.isArray(j)) list = j; } catch(e){}
                            }
                        } catch(e){}
                    }
                } catch (e) {
                    console.warn('OpenAI failed for movies, trying Gemini fallback:', e);
                    apiError = true;
                    status.textContent = 'Trying alternative curator...';
                    
                    // Try Gemini fallback
                    try {
                        const response = await callGeminiRaw(prompt);
                        try {
                            const json = JSON.parse(response);
                            if (Array.isArray(json)) {
                                list = json;
                            } else if (Array.isArray(json?.movies)) {
                                list = json.movies;
                            }
                        } catch {
                            const jsonMatch = response.match(/\[[\s\S]*?\]/);
                            if (jsonMatch) {
                                list = JSON.parse(jsonMatch[0]);
                            }
                        }
                    } catch (geminiError) {
                        console.warn('Gemini also failed for movies:', geminiError);
                        status.textContent = 'Using expertly curated selections...';
                    }
                }

                if (!list || !list.length) {
                    // Use curated fallback selections
                    status.textContent = 'Using expertly curated selections...';
                    const fallbackFilms = {
                        contemplative: [
                            { title: 'Stalker', year: '1979', reason: 'Tarkovsky\'s philosophical journey into desire and consciousness.' },
                            { title: 'Mirror', year: '1975', reason: 'A poetic meditation on memory and time.' },
                            { title: 'Solaris', year: '1972', reason: 'Profound exploration of human nature and understanding.' }
                        ],
                        romantic: [
                            { title: 'In the Mood for Love', year: '2000', reason: 'Wong Kar-wai\'s masterpiece of restrained longing.' },
                            { title: 'Chungking Express', year: '1994', reason: 'Playful yet deeply romantic urban love stories.' },
                            { title: 'Before Sunrise', year: '1995', reason: 'Perfect dialogue-driven romance in Vienna.' }
                        ],
                        dark: [
                            { title: 'Persona', year: '1966', reason: 'Bergman\'s psychological masterpiece on identity.' },
                            { title: 'Mulholland Drive', year: '2001', reason: 'Lynch\'s enigmatic exploration of Hollywood darkness.' },
                            { title: 'The Piano Teacher', year: '2001', reason: 'Haneke\'s unsettling study of repression and desire.' }
                        ],
                        uplifting: [
                            { title: 'Wings of Desire', year: '1987', reason: 'Wenders\' poetic celebration of human existence.' },
                            { title: 'The Double Life of Veronique', year: '1991', reason: 'Kieslowski\'s luminous tale of connection and music.' },
                            { title: 'A Separation', year: '2011', reason: 'Humanistic drama about family and moral complexity.' }
                        ],
                        philosophical: [
                            { title: 'The Tree of Life', year: '2011', reason: 'Malick\'s cosmic meditation on existence and meaning.' },
                            { title: 'Synecdoche, New York', year: '2008', reason: 'Kaufman\'s profound exploration of art and mortality.' },
                            { title: 'The Seventh Seal', year: '1957', reason: 'Bergman\'s medieval allegory confronting death and faith.' }
                        ],
                        mysterious: [
                            { title: 'Vertigo', year: '1958', reason: 'Hitchcock\'s psychological thriller about obsession and illusion.' },
                            { title: 'Last Year at Marienbad', year: '1961', reason: 'Resnais\' enigmatic puzzle of memory and reality.' },
                            { title: '2001: A Space Odyssey', year: '1968', reason: 'Kubrick\'s mysterious journey through evolution and consciousness.' }
                        ],
                        melancholic: [
                            { title: 'Manchester by the Sea', year: '2016', reason: 'Lonergan\'s tender portrait of grief and healing.' },
                            { title: 'Tokyo Story', year: '1953', reason: 'Ozu\'s gentle meditation on family and the passage of time.' },
                            { title: 'Her', year: '2013', reason: 'Jonze\'s bittersweet exploration of love and loneliness.' }
                        ],
                        surreal: [
                            { title: '8½', year: '1963', reason: 'Fellini\'s dreamlike exploration of artistic creation.' },
                            { title: 'The Holy Mountain', year: '1973', reason: 'Jodorowsky\'s visionary, symbolic journey of enlightenment.' },
                            { title: 'Eraserhead', year: '1977', reason: 'Lynch\'s nightmarish industrial fever dream.' }
                        ],
                        nostalgic: [
                            { title: 'Cinema Paradiso', year: '1988', reason: 'Tornatore\'s loving tribute to the magic of movies.' },
                            { title: 'Amour', year: '2012', reason: 'Haneke\'s tender portrayal of enduring love.' },
                            { title: 'The 400 Blows', year: '1959', reason: 'Truffaut\'s autobiographical coming-of-age masterpiece.' }
                        ]
                    };
                    list = fallbackFilms[mood] || fallbackFilms.contemplative;
                    if (apiError) {
                        status.textContent = 'Using curated backup selections...';
                    }
                }

                status.textContent = 'Loading movie posters...';
                results.innerHTML = '';
                
                const tmdbKey = getClientKey('TMDB_API_KEY');
                const displayList = list.slice(0, 6);
                
                for (let i = 0; i < displayList.length; i++) {
                    const item = displayList[i];
                    const card = document.createElement('div');
                    card.className = 'movie-card';
                    card.style.opacity = '0';
                    card.style.transform = 'translateY(20px)';
                    card.style.transition = 'all 0.3s ease';
                    
                    const poster = document.createElement('img');
                    poster.className = 'movie-poster';
                    poster.alt = item.title;
                    poster.style.background = 'linear-gradient(135deg, #c9a961, #8b7355)';
                    const placeholder = document.createElement('div');
                    placeholder.className = 'movie-poster-placeholder';
                    placeholder.style.width = '100%';
                    placeholder.style.height = '240px';
                    placeholder.style.borderRadius = '6px';
                    placeholder.style.display = 'flex';
                    placeholder.style.alignItems = 'center';
                    placeholder.style.justifyContent = 'center';
                    placeholder.style.background = 'linear-gradient(135deg, #2c2c2c, #1a1a1a)';
                    placeholder.style.color = '#c9a961';
                    placeholder.style.fontSize = '1.25rem';
                    placeholder.textContent = 'FILM';
                    
                    const titleEl = document.createElement('div'); 
                    titleEl.className = 'movie-title'; 
                    titleEl.textContent = `${item.title}${item.year ? ` (${item.year})` : ''}`;
                    
                    const reasonEl = document.createElement('div'); 
                    reasonEl.className = 'movie-reason'; 
                    reasonEl.textContent = item.reason || '';
                    
                    card.appendChild(placeholder);
                    card.appendChild(poster);
                    card.appendChild(titleEl);
                    card.appendChild(reasonEl);
                    results.appendChild(card);
                    
                    setTimeout(() => {
                        card.style.opacity = '1';
                        card.style.transform = 'translateY(0)';
                    }, i * 100);

                    if (tmdbKey && item.title) {
                        try {
                            const q = encodeURIComponent(item.title);
                            const y = item.year ? `&year=${encodeURIComponent(item.year)}` : '';
                            const url = `https://api.themoviedb.org/3/search/movie?api_key=${encodeURIComponent(tmdbKey)}&query=${q}${y}`;
                            const response = await fetch(url);
                            if (response.ok) {
                                const data = await response.json();
                                const movie = data.results?.[0];
                                if (movie?.poster_path) {
                                    poster.src = `https://image.tmdb.org/t/p/w500${movie.poster_path}`;
                                    poster.style.background = '';
                                    placeholder.style.display = 'none';
                                    poster.style.display = '';
                                } else {
                                    // no poster found
                                    poster.removeAttribute('src');
                                    poster.style.display = 'none';
                                    placeholder.style.display = 'flex';
                                }
                            } else {
                                poster.removeAttribute('src');
                                poster.style.display = 'none';
                                placeholder.style.display = 'flex';
                            }
                        } catch (e) { 
                            console.warn('TMDB fetch failed for:', item.title, e);
                            poster.removeAttribute('src');
                            poster.style.display = 'none';
                            placeholder.style.display = 'flex';
                        }
                    } else {
                        poster.removeAttribute('src');
                        poster.style.display = 'none';
                        placeholder.style.display = 'flex';
                        if (!tmdbKey) status.textContent = 'Add TMDb API key in Settings for movie posters';
                    }
                }

                if (tmdbKey) {
                    status.textContent = 'Films curated successfully with posters!';
                } else {
                    status.textContent = 'Films curated successfully!';
                }
                
                setTimeout(() => {
                    status.textContent = '';
                }, 3000);
                
                suggestBtn.disabled = false;
            });
        }

        // movies initialization is invoked from the main DOMContentLoaded handler

    </script>
</body>
</html>
